// Code generated from Parser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Parser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

import (
	expressions "TSwift/Classes/Expressions"
	instructions "TSwift/Classes/Instructions"
	interfaces "TSwift/Classes/Interfaces"
	utils "TSwift/Classes/Utils"
	vector "TSwift/Classes/Vector"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ParserParser struct {
	*antlr.BaseParser
}

var ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func parserParserInit() {
	staticData := &ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'Int'", "'Float'", "'String'", "'Bool'", "'Character'", "'var'",
		"'let'", "'if'", "'else'", "'for'", "'while'", "'guard'", "'switch'",
		"'case'", "'default'", "'break'", "'continue'", "'return'", "'true'",
		"'false'", "'nil'", "'func'", "'inout'", "'in'", "'append'", "'removeLast'",
		"'remove'", "'at'", "'isEmpty'", "'count'", "'repeating'", "'struct'",
		"'mutating'", "'self'", "'print'", "'->'", "'_'", "", "", "", "", "",
		"'+='", "'-='", "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", "'!='", "'<='",
		"'>='", "'='", "'<'", "'>'", "'&&'", "'||'", "'!'", "'('", "')'", "'{'",
		"'}'", "'['", "']'", "'.'", "','", "':'", "';'", "'?'", "'&'", "'\\n'",
	}
	staticData.SymbolicNames = []string{
		"", "RW_Int", "RW_Float", "RW_String", "RW_Bool", "RW_Character", "RW_var",
		"RW_let", "RW_if", "RW_else", "RW_for", "RW_while", "RW_guard", "RW_switch",
		"RW_case", "RW_default", "RW_break", "RW_continue", "RW_return", "RW_true",
		"RW_false", "RW_nil", "RW_func", "RW_inout", "RW_in", "RW_append", "RW_removeLast",
		"RW_remove", "RW_at", "RW_isEmpty", "RW_count", "RW_repeating", "RW_struct",
		"RW_mutating", "RW_self", "RW_print", "TK_prompt", "TK_under", "TK_char",
		"TK_string", "TK_int", "TK_float", "TK_id", "TK_add", "TK_sub", "TK_plus",
		"TK_minus", "TK_mult", "TK_div", "TK_mod", "TK_equequ", "TK_notequ",
		"TK_lessequ", "TK_moreequ", "TK_equ", "TK_less", "TK_more", "TK_and",
		"TK_or", "TK_not", "TK_lpar", "TK_rpar", "TK_lbrc", "TK_rbrc", "TK_lbrk",
		"TK_rbrk", "TK_dot", "TK_comma", "TK_colon", "TK_semicolon", "TK_question",
		"TK_amp", "NEWLINE", "UNUSED_", "COMMENTS_", "COMMENTM_", "ERROR",
	}
	staticData.RuleNames = []string{
		"init", "instsglobal", "instglobal", "callfunc", "listargs", "arg",
		"decvar", "deccst", "declfunc", "listparams", "param", "typeparam",
		"ifstruct", "switchstruct", "envs", "casesdefault", "cases", "case",
		"default", "loopfor", "range", "loopwhile", "guard", "reasign", "addsub",
		"decvector", "defvector", "listexp", "funcvector", "decmatrix", "defmatrix",
		"matrix", "vectors", "vector", "simplematrix", "typematrix", "reasignvector",
		"dims", "defstruct", "listattribs", "attrib", "decstruct", "listdupla",
		"useattribs", "obj", "useattribs1", "print", "env", "instructions",
		"instruction", "type", "typeComp", "exp",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 76, 1060, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 113, 8, 0, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 123, 8, 1, 10, 1, 12, 1, 126, 9,
		1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 136, 8, 2, 1,
		2, 1, 2, 3, 2, 140, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 3, 3, 152, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 5, 4, 163, 8, 4, 10, 4, 12, 4, 166, 9, 4, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 3, 5, 186, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 3, 6, 209, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 225, 8, 7, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 261, 8,
		8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 272, 8,
		9, 10, 9, 12, 9, 275, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 325, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 333, 8,
		11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 354,
		8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 369, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 381, 8, 15, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 391, 8, 16, 10, 16,
		12, 16, 394, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 3, 17, 407, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 417, 8, 18, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		3, 19, 433, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		3, 25, 495, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26,
		514, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 5, 27, 525, 8, 27, 10, 27, 12, 27, 528, 9, 27, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		3, 28, 554, 8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 570, 8, 29, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 578, 8, 30, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 5, 32, 594, 8, 32, 10, 32, 12, 32, 597, 9, 32, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 607, 8, 33, 1, 34, 1, 34,
		1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 3, 34, 633, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 3, 35, 645, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 5, 37, 665, 8, 37, 10, 37, 12, 37, 668, 9, 37,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 3, 39, 679,
		8, 39, 1, 39, 1, 39, 3, 39, 683, 8, 39, 1, 39, 5, 39, 686, 8, 39, 10, 39,
		12, 39, 689, 9, 39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 695, 8, 40, 1, 40,
		1, 40, 3, 40, 699, 8, 40, 1, 40, 3, 40, 702, 8, 40, 1, 40, 3, 40, 705,
		8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 711, 8, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 3, 41, 717, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41,
		724, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 730, 8, 41, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 741, 8, 42, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 750, 8, 43, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 758, 8, 44, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 765, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 777, 8, 46, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 787, 8, 47, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 797, 8, 48, 10, 48, 12,
		48, 800, 9, 48, 1, 49, 1, 49, 3, 49, 804, 8, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 810, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 3, 49, 831, 8, 49, 1, 49, 1, 49, 3, 49, 835, 8, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 3, 49, 841, 8, 49, 1, 49, 1, 49, 3, 49, 845, 8, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 3, 49, 851, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 857, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 863, 8, 49, 1, 49,
		1, 49, 3, 49, 867, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 873, 8, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 879, 8, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 885, 8, 49, 1, 49, 1, 49, 3, 49, 889, 8, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 3, 49, 895, 8, 49, 1, 49, 1, 49, 3, 49, 899, 8, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 3, 49, 905, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 912, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 918, 8, 49, 1, 49,
		1, 49, 1, 49, 3, 49, 923, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 928, 8, 49,
		1, 49, 3, 49, 931, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 3, 50, 943, 8, 50, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 3, 51, 950, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 973, 8, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 3, 52, 980, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52,
		987, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 1010, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1055, 8, 52, 10, 52, 12,
		52, 1058, 9, 52, 1, 52, 0, 10, 2, 8, 18, 32, 54, 64, 74, 78, 96, 104, 53,
		0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
		38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
		74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 0, 8,
		2, 0, 37, 37, 42, 42, 1, 0, 43, 44, 1, 0, 6, 7, 1, 0, 47, 49, 1, 0, 45,
		46, 1, 0, 52, 53, 1, 0, 55, 56, 1, 0, 50, 51, 1146, 0, 112, 1, 0, 0, 0,
		2, 114, 1, 0, 0, 0, 4, 139, 1, 0, 0, 0, 6, 151, 1, 0, 0, 0, 8, 153, 1,
		0, 0, 0, 10, 185, 1, 0, 0, 0, 12, 208, 1, 0, 0, 0, 14, 224, 1, 0, 0, 0,
		16, 260, 1, 0, 0, 0, 18, 262, 1, 0, 0, 0, 20, 324, 1, 0, 0, 0, 22, 332,
		1, 0, 0, 0, 24, 353, 1, 0, 0, 0, 26, 355, 1, 0, 0, 0, 28, 368, 1, 0, 0,
		0, 30, 380, 1, 0, 0, 0, 32, 382, 1, 0, 0, 0, 34, 406, 1, 0, 0, 0, 36, 416,
		1, 0, 0, 0, 38, 432, 1, 0, 0, 0, 40, 434, 1, 0, 0, 0, 42, 441, 1, 0, 0,
		0, 44, 446, 1, 0, 0, 0, 46, 452, 1, 0, 0, 0, 48, 457, 1, 0, 0, 0, 50, 494,
		1, 0, 0, 0, 52, 513, 1, 0, 0, 0, 54, 515, 1, 0, 0, 0, 56, 553, 1, 0, 0,
		0, 58, 569, 1, 0, 0, 0, 60, 577, 1, 0, 0, 0, 62, 579, 1, 0, 0, 0, 64, 584,
		1, 0, 0, 0, 66, 606, 1, 0, 0, 0, 68, 632, 1, 0, 0, 0, 70, 644, 1, 0, 0,
		0, 72, 646, 1, 0, 0, 0, 74, 652, 1, 0, 0, 0, 76, 669, 1, 0, 0, 0, 78, 675,
		1, 0, 0, 0, 80, 704, 1, 0, 0, 0, 82, 729, 1, 0, 0, 0, 84, 740, 1, 0, 0,
		0, 86, 749, 1, 0, 0, 0, 88, 757, 1, 0, 0, 0, 90, 764, 1, 0, 0, 0, 92, 776,
		1, 0, 0, 0, 94, 786, 1, 0, 0, 0, 96, 788, 1, 0, 0, 0, 98, 930, 1, 0, 0,
		0, 100, 942, 1, 0, 0, 0, 102, 949, 1, 0, 0, 0, 104, 1009, 1, 0, 0, 0, 106,
		107, 3, 2, 1, 0, 107, 108, 5, 0, 0, 1, 108, 109, 6, 0, -1, 0, 109, 113,
		1, 0, 0, 0, 110, 111, 5, 0, 0, 1, 111, 113, 6, 0, -1, 0, 112, 106, 1, 0,
		0, 0, 112, 110, 1, 0, 0, 0, 113, 1, 1, 0, 0, 0, 114, 115, 6, 1, -1, 0,
		115, 116, 3, 4, 2, 0, 116, 117, 6, 1, -1, 0, 117, 124, 1, 0, 0, 0, 118,
		119, 10, 2, 0, 0, 119, 120, 3, 4, 2, 0, 120, 121, 6, 1, -1, 0, 121, 123,
		1, 0, 0, 0, 122, 118, 1, 0, 0, 0, 123, 126, 1, 0, 0, 0, 124, 122, 1, 0,
		0, 0, 124, 125, 1, 0, 0, 0, 125, 3, 1, 0, 0, 0, 126, 124, 1, 0, 0, 0, 127,
		128, 3, 98, 49, 0, 128, 129, 6, 2, -1, 0, 129, 140, 1, 0, 0, 0, 130, 131,
		3, 16, 8, 0, 131, 132, 6, 2, -1, 0, 132, 140, 1, 0, 0, 0, 133, 135, 3,
		76, 38, 0, 134, 136, 5, 69, 0, 0, 135, 134, 1, 0, 0, 0, 135, 136, 1, 0,
		0, 0, 136, 137, 1, 0, 0, 0, 137, 138, 6, 2, -1, 0, 138, 140, 1, 0, 0, 0,
		139, 127, 1, 0, 0, 0, 139, 130, 1, 0, 0, 0, 139, 133, 1, 0, 0, 0, 140,
		5, 1, 0, 0, 0, 141, 142, 5, 42, 0, 0, 142, 143, 5, 60, 0, 0, 143, 144,
		3, 8, 4, 0, 144, 145, 5, 61, 0, 0, 145, 146, 6, 3, -1, 0, 146, 152, 1,
		0, 0, 0, 147, 148, 5, 42, 0, 0, 148, 149, 5, 60, 0, 0, 149, 150, 5, 61,
		0, 0, 150, 152, 6, 3, -1, 0, 151, 141, 1, 0, 0, 0, 151, 147, 1, 0, 0, 0,
		152, 7, 1, 0, 0, 0, 153, 154, 6, 4, -1, 0, 154, 155, 3, 10, 5, 0, 155,
		156, 6, 4, -1, 0, 156, 164, 1, 0, 0, 0, 157, 158, 10, 2, 0, 0, 158, 159,
		5, 67, 0, 0, 159, 160, 3, 10, 5, 0, 160, 161, 6, 4, -1, 0, 161, 163, 1,
		0, 0, 0, 162, 157, 1, 0, 0, 0, 163, 166, 1, 0, 0, 0, 164, 162, 1, 0, 0,
		0, 164, 165, 1, 0, 0, 0, 165, 9, 1, 0, 0, 0, 166, 164, 1, 0, 0, 0, 167,
		168, 5, 42, 0, 0, 168, 169, 5, 68, 0, 0, 169, 170, 5, 71, 0, 0, 170, 171,
		3, 104, 52, 0, 171, 172, 6, 5, -1, 0, 172, 186, 1, 0, 0, 0, 173, 174, 5,
		42, 0, 0, 174, 175, 5, 68, 0, 0, 175, 176, 3, 104, 52, 0, 176, 177, 6,
		5, -1, 0, 177, 186, 1, 0, 0, 0, 178, 179, 5, 71, 0, 0, 179, 180, 3, 104,
		52, 0, 180, 181, 6, 5, -1, 0, 181, 186, 1, 0, 0, 0, 182, 183, 3, 104, 52,
		0, 183, 184, 6, 5, -1, 0, 184, 186, 1, 0, 0, 0, 185, 167, 1, 0, 0, 0, 185,
		173, 1, 0, 0, 0, 185, 178, 1, 0, 0, 0, 185, 182, 1, 0, 0, 0, 186, 11, 1,
		0, 0, 0, 187, 188, 5, 6, 0, 0, 188, 189, 5, 42, 0, 0, 189, 190, 5, 68,
		0, 0, 190, 191, 3, 100, 50, 0, 191, 192, 5, 54, 0, 0, 192, 193, 3, 104,
		52, 0, 193, 194, 6, 6, -1, 0, 194, 209, 1, 0, 0, 0, 195, 196, 5, 6, 0,
		0, 196, 197, 5, 42, 0, 0, 197, 198, 5, 68, 0, 0, 198, 199, 3, 100, 50,
		0, 199, 200, 5, 70, 0, 0, 200, 201, 6, 6, -1, 0, 201, 209, 1, 0, 0, 0,
		202, 203, 5, 6, 0, 0, 203, 204, 5, 42, 0, 0, 204, 205, 5, 54, 0, 0, 205,
		206, 3, 104, 52, 0, 206, 207, 6, 6, -1, 0, 207, 209, 1, 0, 0, 0, 208, 187,
		1, 0, 0, 0, 208, 195, 1, 0, 0, 0, 208, 202, 1, 0, 0, 0, 209, 13, 1, 0,
		0, 0, 210, 211, 5, 7, 0, 0, 211, 212, 5, 42, 0, 0, 212, 213, 5, 68, 0,
		0, 213, 214, 3, 100, 50, 0, 214, 215, 5, 54, 0, 0, 215, 216, 3, 104, 52,
		0, 216, 217, 6, 7, -1, 0, 217, 225, 1, 0, 0, 0, 218, 219, 5, 7, 0, 0, 219,
		220, 5, 42, 0, 0, 220, 221, 5, 54, 0, 0, 221, 222, 3, 104, 52, 0, 222,
		223, 6, 7, -1, 0, 223, 225, 1, 0, 0, 0, 224, 210, 1, 0, 0, 0, 224, 218,
		1, 0, 0, 0, 225, 15, 1, 0, 0, 0, 226, 227, 5, 22, 0, 0, 227, 228, 5, 42,
		0, 0, 228, 229, 5, 60, 0, 0, 229, 230, 3, 18, 9, 0, 230, 231, 5, 61, 0,
		0, 231, 232, 5, 36, 0, 0, 232, 233, 3, 102, 51, 0, 233, 234, 3, 94, 47,
		0, 234, 235, 6, 8, -1, 0, 235, 261, 1, 0, 0, 0, 236, 237, 5, 22, 0, 0,
		237, 238, 5, 42, 0, 0, 238, 239, 5, 60, 0, 0, 239, 240, 3, 18, 9, 0, 240,
		241, 5, 61, 0, 0, 241, 242, 3, 94, 47, 0, 242, 243, 6, 8, -1, 0, 243, 261,
		1, 0, 0, 0, 244, 245, 5, 22, 0, 0, 245, 246, 5, 42, 0, 0, 246, 247, 5,
		60, 0, 0, 247, 248, 5, 61, 0, 0, 248, 249, 5, 36, 0, 0, 249, 250, 3, 102,
		51, 0, 250, 251, 3, 94, 47, 0, 251, 252, 6, 8, -1, 0, 252, 261, 1, 0, 0,
		0, 253, 254, 5, 22, 0, 0, 254, 255, 5, 42, 0, 0, 255, 256, 5, 60, 0, 0,
		256, 257, 5, 61, 0, 0, 257, 258, 3, 94, 47, 0, 258, 259, 6, 8, -1, 0, 259,
		261, 1, 0, 0, 0, 260, 226, 1, 0, 0, 0, 260, 236, 1, 0, 0, 0, 260, 244,
		1, 0, 0, 0, 260, 253, 1, 0, 0, 0, 261, 17, 1, 0, 0, 0, 262, 263, 6, 9,
		-1, 0, 263, 264, 3, 20, 10, 0, 264, 265, 6, 9, -1, 0, 265, 273, 1, 0, 0,
		0, 266, 267, 10, 2, 0, 0, 267, 268, 5, 67, 0, 0, 268, 269, 3, 20, 10, 0,
		269, 270, 6, 9, -1, 0, 270, 272, 1, 0, 0, 0, 271, 266, 1, 0, 0, 0, 272,
		275, 1, 0, 0, 0, 273, 271, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 19, 1,
		0, 0, 0, 275, 273, 1, 0, 0, 0, 276, 277, 5, 42, 0, 0, 277, 278, 5, 42,
		0, 0, 278, 279, 5, 68, 0, 0, 279, 280, 5, 23, 0, 0, 280, 281, 3, 22, 11,
		0, 281, 282, 6, 10, -1, 0, 282, 325, 1, 0, 0, 0, 283, 284, 5, 42, 0, 0,
		284, 285, 5, 68, 0, 0, 285, 286, 5, 23, 0, 0, 286, 287, 3, 22, 11, 0, 287,
		288, 6, 10, -1, 0, 288, 325, 1, 0, 0, 0, 289, 290, 5, 37, 0, 0, 290, 291,
		5, 42, 0, 0, 291, 292, 5, 68, 0, 0, 292, 293, 5, 23, 0, 0, 293, 294, 3,
		22, 11, 0, 294, 295, 6, 10, -1, 0, 295, 325, 1, 0, 0, 0, 296, 297, 5, 42,
		0, 0, 297, 298, 5, 68, 0, 0, 298, 299, 5, 23, 0, 0, 299, 300, 3, 22, 11,
		0, 300, 301, 6, 10, -1, 0, 301, 325, 1, 0, 0, 0, 302, 303, 5, 42, 0, 0,
		303, 304, 5, 42, 0, 0, 304, 305, 5, 68, 0, 0, 305, 306, 3, 22, 11, 0, 306,
		307, 6, 10, -1, 0, 307, 325, 1, 0, 0, 0, 308, 309, 5, 42, 0, 0, 309, 310,
		5, 68, 0, 0, 310, 311, 3, 22, 11, 0, 311, 312, 6, 10, -1, 0, 312, 325,
		1, 0, 0, 0, 313, 314, 5, 37, 0, 0, 314, 315, 5, 42, 0, 0, 315, 316, 5,
		68, 0, 0, 316, 317, 3, 22, 11, 0, 317, 318, 6, 10, -1, 0, 318, 325, 1,
		0, 0, 0, 319, 320, 5, 42, 0, 0, 320, 321, 5, 68, 0, 0, 321, 322, 3, 22,
		11, 0, 322, 323, 6, 10, -1, 0, 323, 325, 1, 0, 0, 0, 324, 276, 1, 0, 0,
		0, 324, 283, 1, 0, 0, 0, 324, 289, 1, 0, 0, 0, 324, 296, 1, 0, 0, 0, 324,
		302, 1, 0, 0, 0, 324, 308, 1, 0, 0, 0, 324, 313, 1, 0, 0, 0, 324, 319,
		1, 0, 0, 0, 325, 21, 1, 0, 0, 0, 326, 327, 3, 102, 51, 0, 327, 328, 6,
		11, -1, 0, 328, 333, 1, 0, 0, 0, 329, 330, 3, 70, 35, 0, 330, 331, 6, 11,
		-1, 0, 331, 333, 1, 0, 0, 0, 332, 326, 1, 0, 0, 0, 332, 329, 1, 0, 0, 0,
		333, 23, 1, 0, 0, 0, 334, 335, 5, 8, 0, 0, 335, 336, 3, 104, 52, 0, 336,
		337, 3, 94, 47, 0, 337, 338, 5, 9, 0, 0, 338, 339, 3, 24, 12, 0, 339, 340,
		6, 12, -1, 0, 340, 354, 1, 0, 0, 0, 341, 342, 5, 8, 0, 0, 342, 343, 3,
		104, 52, 0, 343, 344, 3, 94, 47, 0, 344, 345, 5, 9, 0, 0, 345, 346, 3,
		94, 47, 0, 346, 347, 6, 12, -1, 0, 347, 354, 1, 0, 0, 0, 348, 349, 5, 8,
		0, 0, 349, 350, 3, 104, 52, 0, 350, 351, 3, 94, 47, 0, 351, 352, 6, 12,
		-1, 0, 352, 354, 1, 0, 0, 0, 353, 334, 1, 0, 0, 0, 353, 341, 1, 0, 0, 0,
		353, 348, 1, 0, 0, 0, 354, 25, 1, 0, 0, 0, 355, 356, 5, 13, 0, 0, 356,
		357, 3, 104, 52, 0, 357, 358, 3, 28, 14, 0, 358, 359, 6, 13, -1, 0, 359,
		27, 1, 0, 0, 0, 360, 361, 5, 62, 0, 0, 361, 362, 3, 30, 15, 0, 362, 363,
		5, 63, 0, 0, 363, 364, 6, 14, -1, 0, 364, 369, 1, 0, 0, 0, 365, 366, 5,
		62, 0, 0, 366, 367, 5, 63, 0, 0, 367, 369, 6, 14, -1, 0, 368, 360, 1, 0,
		0, 0, 368, 365, 1, 0, 0, 0, 369, 29, 1, 0, 0, 0, 370, 371, 3, 32, 16, 0,
		371, 372, 3, 36, 18, 0, 372, 373, 6, 15, -1, 0, 373, 381, 1, 0, 0, 0, 374,
		375, 3, 32, 16, 0, 375, 376, 6, 15, -1, 0, 376, 381, 1, 0, 0, 0, 377, 378,
		3, 36, 18, 0, 378, 379, 6, 15, -1, 0, 379, 381, 1, 0, 0, 0, 380, 370, 1,
		0, 0, 0, 380, 374, 1, 0, 0, 0, 380, 377, 1, 0, 0, 0, 381, 31, 1, 0, 0,
		0, 382, 383, 6, 16, -1, 0, 383, 384, 3, 34, 17, 0, 384, 385, 6, 16, -1,
		0, 385, 392, 1, 0, 0, 0, 386, 387, 10, 2, 0, 0, 387, 388, 3, 34, 17, 0,
		388, 389, 6, 16, -1, 0, 389, 391, 1, 0, 0, 0, 390, 386, 1, 0, 0, 0, 391,
		394, 1, 0, 0, 0, 392, 390, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 33, 1,
		0, 0, 0, 394, 392, 1, 0, 0, 0, 395, 396, 5, 14, 0, 0, 396, 397, 3, 104,
		52, 0, 397, 398, 5, 68, 0, 0, 398, 399, 3, 96, 48, 0, 399, 400, 6, 17,
		-1, 0, 400, 407, 1, 0, 0, 0, 401, 402, 5, 14, 0, 0, 402, 403, 3, 104, 52,
		0, 403, 404, 5, 68, 0, 0, 404, 405, 6, 17, -1, 0, 405, 407, 1, 0, 0, 0,
		406, 395, 1, 0, 0, 0, 406, 401, 1, 0, 0, 0, 407, 35, 1, 0, 0, 0, 408, 409,
		5, 15, 0, 0, 409, 410, 5, 68, 0, 0, 410, 411, 3, 96, 48, 0, 411, 412, 6,
		18, -1, 0, 412, 417, 1, 0, 0, 0, 413, 414, 5, 15, 0, 0, 414, 415, 5, 68,
		0, 0, 415, 417, 6, 18, -1, 0, 416, 408, 1, 0, 0, 0, 416, 413, 1, 0, 0,
		0, 417, 37, 1, 0, 0, 0, 418, 419, 5, 10, 0, 0, 419, 420, 7, 0, 0, 0, 420,
		421, 5, 24, 0, 0, 421, 422, 3, 40, 20, 0, 422, 423, 3, 94, 47, 0, 423,
		424, 6, 19, -1, 0, 424, 433, 1, 0, 0, 0, 425, 426, 5, 10, 0, 0, 426, 427,
		7, 0, 0, 0, 427, 428, 5, 24, 0, 0, 428, 429, 3, 104, 52, 0, 429, 430, 3,
		94, 47, 0, 430, 431, 6, 19, -1, 0, 431, 433, 1, 0, 0, 0, 432, 418, 1, 0,
		0, 0, 432, 425, 1, 0, 0, 0, 433, 39, 1, 0, 0, 0, 434, 435, 3, 104, 52,
		0, 435, 436, 5, 66, 0, 0, 436, 437, 5, 66, 0, 0, 437, 438, 5, 66, 0, 0,
		438, 439, 3, 104, 52, 0, 439, 440, 6, 20, -1, 0, 440, 41, 1, 0, 0, 0, 441,
		442, 5, 11, 0, 0, 442, 443, 3, 104, 52, 0, 443, 444, 3, 94, 47, 0, 444,
		445, 6, 21, -1, 0, 445, 43, 1, 0, 0, 0, 446, 447, 5, 12, 0, 0, 447, 448,
		3, 104, 52, 0, 448, 449, 5, 9, 0, 0, 449, 450, 3, 94, 47, 0, 450, 451,
		6, 22, -1, 0, 451, 45, 1, 0, 0, 0, 452, 453, 5, 42, 0, 0, 453, 454, 5,
		54, 0, 0, 454, 455, 3, 104, 52, 0, 455, 456, 6, 23, -1, 0, 456, 47, 1,
		0, 0, 0, 457, 458, 5, 42, 0, 0, 458, 459, 7, 1, 0, 0, 459, 460, 3, 104,
		52, 0, 460, 461, 6, 24, -1, 0, 461, 49, 1, 0, 0, 0, 462, 463, 5, 6, 0,
		0, 463, 464, 5, 42, 0, 0, 464, 465, 5, 68, 0, 0, 465, 466, 5, 64, 0, 0,
		466, 467, 3, 102, 51, 0, 467, 468, 5, 65, 0, 0, 468, 469, 5, 54, 0, 0,
		469, 470, 3, 52, 26, 0, 470, 471, 6, 25, -1, 0, 471, 495, 1, 0, 0, 0, 472,
		473, 5, 7, 0, 0, 473, 474, 5, 42, 0, 0, 474, 475, 5, 68, 0, 0, 475, 476,
		5, 64, 0, 0, 476, 477, 3, 102, 51, 0, 477, 478, 5, 65, 0, 0, 478, 479,
		5, 54, 0, 0, 479, 480, 3, 52, 26, 0, 480, 481, 6, 25, -1, 0, 481, 495,
		1, 0, 0, 0, 482, 483, 5, 6, 0, 0, 483, 484, 5, 42, 0, 0, 484, 485, 5, 54,
		0, 0, 485, 486, 3, 52, 26, 0, 486, 487, 6, 25, -1, 0, 487, 495, 1, 0, 0,
		0, 488, 489, 5, 7, 0, 0, 489, 490, 5, 42, 0, 0, 490, 491, 5, 54, 0, 0,
		491, 492, 3, 52, 26, 0, 492, 493, 6, 25, -1, 0, 493, 495, 1, 0, 0, 0, 494,
		462, 1, 0, 0, 0, 494, 472, 1, 0, 0, 0, 494, 482, 1, 0, 0, 0, 494, 488,
		1, 0, 0, 0, 495, 51, 1, 0, 0, 0, 496, 497, 5, 64, 0, 0, 497, 498, 3, 54,
		27, 0, 498, 499, 5, 65, 0, 0, 499, 500, 6, 26, -1, 0, 500, 514, 1, 0, 0,
		0, 501, 502, 5, 64, 0, 0, 502, 503, 5, 65, 0, 0, 503, 514, 6, 26, -1, 0,
		504, 505, 5, 64, 0, 0, 505, 506, 3, 102, 51, 0, 506, 507, 5, 65, 0, 0,
		507, 508, 5, 60, 0, 0, 508, 509, 5, 61, 0, 0, 509, 510, 6, 26, -1, 0, 510,
		514, 1, 0, 0, 0, 511, 512, 5, 42, 0, 0, 512, 514, 6, 26, -1, 0, 513, 496,
		1, 0, 0, 0, 513, 501, 1, 0, 0, 0, 513, 504, 1, 0, 0, 0, 513, 511, 1, 0,
		0, 0, 514, 53, 1, 0, 0, 0, 515, 516, 6, 27, -1, 0, 516, 517, 3, 104, 52,
		0, 517, 518, 6, 27, -1, 0, 518, 526, 1, 0, 0, 0, 519, 520, 10, 2, 0, 0,
		520, 521, 5, 67, 0, 0, 521, 522, 3, 104, 52, 0, 522, 523, 6, 27, -1, 0,
		523, 525, 1, 0, 0, 0, 524, 519, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526,
		524, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 55, 1, 0, 0, 0, 528, 526, 1,
		0, 0, 0, 529, 530, 5, 42, 0, 0, 530, 531, 5, 66, 0, 0, 531, 532, 5, 25,
		0, 0, 532, 533, 5, 60, 0, 0, 533, 534, 3, 104, 52, 0, 534, 535, 5, 61,
		0, 0, 535, 536, 6, 28, -1, 0, 536, 554, 1, 0, 0, 0, 537, 538, 5, 42, 0,
		0, 538, 539, 5, 66, 0, 0, 539, 540, 5, 26, 0, 0, 540, 541, 5, 60, 0, 0,
		541, 542, 5, 61, 0, 0, 542, 554, 6, 28, -1, 0, 543, 544, 5, 42, 0, 0, 544,
		545, 5, 66, 0, 0, 545, 546, 5, 27, 0, 0, 546, 547, 5, 60, 0, 0, 547, 548,
		5, 28, 0, 0, 548, 549, 5, 68, 0, 0, 549, 550, 3, 104, 52, 0, 550, 551,
		5, 61, 0, 0, 551, 552, 6, 28, -1, 0, 552, 554, 1, 0, 0, 0, 553, 529, 1,
		0, 0, 0, 553, 537, 1, 0, 0, 0, 553, 543, 1, 0, 0, 0, 554, 57, 1, 0, 0,
		0, 555, 556, 5, 6, 0, 0, 556, 557, 5, 42, 0, 0, 557, 558, 5, 68, 0, 0,
		558, 559, 3, 70, 35, 0, 559, 560, 5, 54, 0, 0, 560, 561, 3, 60, 30, 0,
		561, 562, 6, 29, -1, 0, 562, 570, 1, 0, 0, 0, 563, 564, 5, 6, 0, 0, 564,
		565, 5, 42, 0, 0, 565, 566, 5, 54, 0, 0, 566, 567, 3, 60, 30, 0, 567, 568,
		6, 29, -1, 0, 568, 570, 1, 0, 0, 0, 569, 555, 1, 0, 0, 0, 569, 563, 1,
		0, 0, 0, 570, 59, 1, 0, 0, 0, 571, 572, 3, 62, 31, 0, 572, 573, 6, 30,
		-1, 0, 573, 578, 1, 0, 0, 0, 574, 575, 3, 68, 34, 0, 575, 576, 6, 30, -1,
		0, 576, 578, 1, 0, 0, 0, 577, 571, 1, 0, 0, 0, 577, 574, 1, 0, 0, 0, 578,
		61, 1, 0, 0, 0, 579, 580, 5, 64, 0, 0, 580, 581, 3, 64, 32, 0, 581, 582,
		5, 65, 0, 0, 582, 583, 6, 31, -1, 0, 583, 63, 1, 0, 0, 0, 584, 585, 6,
		32, -1, 0, 585, 586, 3, 66, 33, 0, 586, 587, 6, 32, -1, 0, 587, 595, 1,
		0, 0, 0, 588, 589, 10, 2, 0, 0, 589, 590, 5, 67, 0, 0, 590, 591, 3, 66,
		33, 0, 591, 592, 6, 32, -1, 0, 592, 594, 1, 0, 0, 0, 593, 588, 1, 0, 0,
		0, 594, 597, 1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596,
		65, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 598, 599, 5, 64, 0, 0, 599, 600,
		3, 54, 27, 0, 600, 601, 5, 65, 0, 0, 601, 602, 6, 33, -1, 0, 602, 607,
		1, 0, 0, 0, 603, 604, 3, 62, 31, 0, 604, 605, 6, 33, -1, 0, 605, 607, 1,
		0, 0, 0, 606, 598, 1, 0, 0, 0, 606, 603, 1, 0, 0, 0, 607, 67, 1, 0, 0,
		0, 608, 609, 3, 70, 35, 0, 609, 610, 5, 60, 0, 0, 610, 611, 5, 31, 0, 0,
		611, 612, 5, 68, 0, 0, 612, 613, 3, 68, 34, 0, 613, 614, 5, 67, 0, 0, 614,
		615, 5, 30, 0, 0, 615, 616, 5, 68, 0, 0, 616, 617, 3, 104, 52, 0, 617,
		618, 5, 61, 0, 0, 618, 619, 6, 34, -1, 0, 619, 633, 1, 0, 0, 0, 620, 621,
		3, 70, 35, 0, 621, 622, 5, 60, 0, 0, 622, 623, 5, 31, 0, 0, 623, 624, 5,
		68, 0, 0, 624, 625, 3, 104, 52, 0, 625, 626, 5, 67, 0, 0, 626, 627, 5,
		30, 0, 0, 627, 628, 5, 68, 0, 0, 628, 629, 3, 104, 52, 0, 629, 630, 5,
		61, 0, 0, 630, 631, 6, 34, -1, 0, 631, 633, 1, 0, 0, 0, 632, 608, 1, 0,
		0, 0, 632, 620, 1, 0, 0, 0, 633, 69, 1, 0, 0, 0, 634, 635, 5, 64, 0, 0,
		635, 636, 3, 70, 35, 0, 636, 637, 5, 65, 0, 0, 637, 638, 6, 35, -1, 0,
		638, 645, 1, 0, 0, 0, 639, 640, 5, 64, 0, 0, 640, 641, 3, 100, 50, 0, 641,
		642, 5, 65, 0, 0, 642, 643, 6, 35, -1, 0, 643, 645, 1, 0, 0, 0, 644, 634,
		1, 0, 0, 0, 644, 639, 1, 0, 0, 0, 645, 71, 1, 0, 0, 0, 646, 647, 5, 42,
		0, 0, 647, 648, 3, 74, 37, 0, 648, 649, 5, 54, 0, 0, 649, 650, 3, 104,
		52, 0, 650, 651, 6, 36, -1, 0, 651, 73, 1, 0, 0, 0, 652, 653, 6, 37, -1,
		0, 653, 654, 5, 64, 0, 0, 654, 655, 3, 104, 52, 0, 655, 656, 5, 65, 0,
		0, 656, 657, 6, 37, -1, 0, 657, 666, 1, 0, 0, 0, 658, 659, 10, 2, 0, 0,
		659, 660, 5, 64, 0, 0, 660, 661, 3, 104, 52, 0, 661, 662, 5, 65, 0, 0,
		662, 663, 6, 37, -1, 0, 663, 665, 1, 0, 0, 0, 664, 658, 1, 0, 0, 0, 665,
		668, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 75, 1,
		0, 0, 0, 668, 666, 1, 0, 0, 0, 669, 670, 5, 32, 0, 0, 670, 671, 5, 42,
		0, 0, 671, 672, 5, 62, 0, 0, 672, 673, 3, 78, 39, 0, 673, 674, 5, 63, 0,
		0, 674, 77, 1, 0, 0, 0, 675, 676, 6, 39, -1, 0, 676, 678, 3, 80, 40, 0,
		677, 679, 5, 69, 0, 0, 678, 677, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679,
		687, 1, 0, 0, 0, 680, 682, 10, 2, 0, 0, 681, 683, 5, 69, 0, 0, 682, 681,
		1, 0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684, 686, 3, 80,
		40, 0, 685, 680, 1, 0, 0, 0, 686, 689, 1, 0, 0, 0, 687, 685, 1, 0, 0, 0,
		687, 688, 1, 0, 0, 0, 688, 79, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 690, 691,
		7, 2, 0, 0, 691, 694, 5, 42, 0, 0, 692, 693, 5, 68, 0, 0, 693, 695, 3,
		102, 51, 0, 694, 692, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 698, 1, 0,
		0, 0, 696, 697, 5, 54, 0, 0, 697, 699, 3, 104, 52, 0, 698, 696, 1, 0, 0,
		0, 698, 699, 1, 0, 0, 0, 699, 705, 1, 0, 0, 0, 700, 702, 5, 33, 0, 0, 701,
		700, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 705,
		3, 16, 8, 0, 704, 690, 1, 0, 0, 0, 704, 701, 1, 0, 0, 0, 705, 81, 1, 0,
		0, 0, 706, 707, 7, 2, 0, 0, 707, 710, 5, 42, 0, 0, 708, 709, 5, 68, 0,
		0, 709, 711, 5, 42, 0, 0, 710, 708, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711,
		712, 1, 0, 0, 0, 712, 713, 5, 54, 0, 0, 713, 714, 5, 42, 0, 0, 714, 716,
		5, 60, 0, 0, 715, 717, 3, 84, 42, 0, 716, 715, 1, 0, 0, 0, 716, 717, 1,
		0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 730, 5, 61, 0, 0, 719, 720, 7, 2, 0,
		0, 720, 723, 5, 42, 0, 0, 721, 722, 5, 68, 0, 0, 722, 724, 5, 42, 0, 0,
		723, 721, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725,
		726, 5, 54, 0, 0, 726, 727, 5, 42, 0, 0, 727, 728, 5, 60, 0, 0, 728, 730,
		5, 61, 0, 0, 729, 706, 1, 0, 0, 0, 729, 719, 1, 0, 0, 0, 730, 83, 1, 0,
		0, 0, 731, 732, 5, 42, 0, 0, 732, 733, 5, 68, 0, 0, 733, 734, 3, 104, 52,
		0, 734, 735, 5, 67, 0, 0, 735, 736, 3, 84, 42, 0, 736, 741, 1, 0, 0, 0,
		737, 738, 5, 42, 0, 0, 738, 739, 5, 68, 0, 0, 739, 741, 3, 104, 52, 0,
		740, 731, 1, 0, 0, 0, 740, 737, 1, 0, 0, 0, 741, 85, 1, 0, 0, 0, 742, 743,
		3, 88, 44, 0, 743, 744, 3, 90, 45, 0, 744, 750, 1, 0, 0, 0, 745, 746, 3,
		88, 44, 0, 746, 747, 5, 66, 0, 0, 747, 748, 3, 6, 3, 0, 748, 750, 1, 0,
		0, 0, 749, 742, 1, 0, 0, 0, 749, 745, 1, 0, 0, 0, 750, 87, 1, 0, 0, 0,
		751, 752, 5, 42, 0, 0, 752, 753, 5, 64, 0, 0, 753, 754, 3, 104, 52, 0,
		754, 755, 5, 65, 0, 0, 755, 758, 1, 0, 0, 0, 756, 758, 5, 42, 0, 0, 757,
		751, 1, 0, 0, 0, 757, 756, 1, 0, 0, 0, 758, 89, 1, 0, 0, 0, 759, 760, 5,
		66, 0, 0, 760, 761, 5, 42, 0, 0, 761, 765, 3, 90, 45, 0, 762, 763, 5, 66,
		0, 0, 763, 765, 5, 42, 0, 0, 764, 759, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0,
		765, 91, 1, 0, 0, 0, 766, 767, 5, 35, 0, 0, 767, 768, 5, 60, 0, 0, 768,
		769, 3, 54, 27, 0, 769, 770, 5, 61, 0, 0, 770, 771, 6, 46, -1, 0, 771,
		777, 1, 0, 0, 0, 772, 773, 5, 35, 0, 0, 773, 774, 5, 60, 0, 0, 774, 775,
		5, 61, 0, 0, 775, 777, 6, 46, -1, 0, 776, 766, 1, 0, 0, 0, 776, 772, 1,
		0, 0, 0, 777, 93, 1, 0, 0, 0, 778, 779, 5, 62, 0, 0, 779, 780, 3, 96, 48,
		0, 780, 781, 5, 63, 0, 0, 781, 782, 6, 47, -1, 0, 782, 787, 1, 0, 0, 0,
		783, 784, 5, 62, 0, 0, 784, 785, 5, 63, 0, 0, 785, 787, 6, 47, -1, 0, 786,
		778, 1, 0, 0, 0, 786, 783, 1, 0, 0, 0, 787, 95, 1, 0, 0, 0, 788, 789, 6,
		48, -1, 0, 789, 790, 3, 98, 49, 0, 790, 791, 6, 48, -1, 0, 791, 798, 1,
		0, 0, 0, 792, 793, 10, 2, 0, 0, 793, 794, 3, 98, 49, 0, 794, 795, 6, 48,
		-1, 0, 795, 797, 1, 0, 0, 0, 796, 792, 1, 0, 0, 0, 797, 800, 1, 0, 0, 0,
		798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 97, 1, 0, 0, 0, 800, 798,
		1, 0, 0, 0, 801, 803, 3, 12, 6, 0, 802, 804, 5, 69, 0, 0, 803, 802, 1,
		0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 806, 6, 49, -1,
		0, 806, 931, 1, 0, 0, 0, 807, 809, 3, 14, 7, 0, 808, 810, 5, 69, 0, 0,
		809, 808, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811,
		812, 6, 49, -1, 0, 812, 931, 1, 0, 0, 0, 813, 814, 3, 24, 12, 0, 814, 815,
		6, 49, -1, 0, 815, 931, 1, 0, 0, 0, 816, 817, 3, 26, 13, 0, 817, 818, 6,
		49, -1, 0, 818, 931, 1, 0, 0, 0, 819, 820, 3, 38, 19, 0, 820, 821, 6, 49,
		-1, 0, 821, 931, 1, 0, 0, 0, 822, 823, 3, 42, 21, 0, 823, 824, 6, 49, -1,
		0, 824, 931, 1, 0, 0, 0, 825, 826, 3, 44, 22, 0, 826, 827, 6, 49, -1, 0,
		827, 931, 1, 0, 0, 0, 828, 829, 5, 34, 0, 0, 829, 831, 5, 66, 0, 0, 830,
		828, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0, 832, 834,
		3, 46, 23, 0, 833, 835, 5, 69, 0, 0, 834, 833, 1, 0, 0, 0, 834, 835, 1,
		0, 0, 0, 835, 836, 1, 0, 0, 0, 836, 837, 6, 49, -1, 0, 837, 931, 1, 0,
		0, 0, 838, 839, 5, 34, 0, 0, 839, 841, 5, 66, 0, 0, 840, 838, 1, 0, 0,
		0, 840, 841, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 844, 3, 48, 24, 0,
		843, 845, 5, 69, 0, 0, 844, 843, 1, 0, 0, 0, 844, 845, 1, 0, 0, 0, 845,
		846, 1, 0, 0, 0, 846, 847, 6, 49, -1, 0, 847, 931, 1, 0, 0, 0, 848, 850,
		3, 50, 25, 0, 849, 851, 5, 69, 0, 0, 850, 849, 1, 0, 0, 0, 850, 851, 1,
		0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 853, 6, 49, -1, 0, 853, 931, 1, 0,
		0, 0, 854, 856, 3, 56, 28, 0, 855, 857, 5, 69, 0, 0, 856, 855, 1, 0, 0,
		0, 856, 857, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 859, 6, 49, -1, 0,
		859, 931, 1, 0, 0, 0, 860, 861, 5, 34, 0, 0, 861, 863, 5, 66, 0, 0, 862,
		860, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 866,
		3, 72, 36, 0, 865, 867, 5, 69, 0, 0, 866, 865, 1, 0, 0, 0, 866, 867, 1,
		0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 869, 6, 49, -1, 0, 869, 931, 1, 0,
		0, 0, 870, 872, 3, 58, 29, 0, 871, 873, 5, 69, 0, 0, 872, 871, 1, 0, 0,
		0, 872, 873, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 875, 6, 49, -1, 0,
		875, 931, 1, 0, 0, 0, 876, 878, 3, 82, 41, 0, 877, 879, 5, 69, 0, 0, 878,
		877, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 881,
		6, 49, -1, 0, 881, 931, 1, 0, 0, 0, 882, 883, 5, 34, 0, 0, 883, 885, 5,
		66, 0, 0, 884, 882, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 886, 1, 0, 0,
		0, 886, 888, 3, 86, 43, 0, 887, 889, 5, 69, 0, 0, 888, 887, 1, 0, 0, 0,
		888, 889, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 891, 6, 49, -1, 0, 891,
		931, 1, 0, 0, 0, 892, 893, 5, 34, 0, 0, 893, 895, 5, 66, 0, 0, 894, 892,
		1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 3, 6,
		3, 0, 897, 899, 5, 69, 0, 0, 898, 897, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0,
		899, 900, 1, 0, 0, 0, 900, 901, 6, 49, -1, 0, 901, 931, 1, 0, 0, 0, 902,
		904, 3, 92, 46, 0, 903, 905, 5, 69, 0, 0, 904, 903, 1, 0, 0, 0, 904, 905,
		1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906, 907, 6, 49, -1, 0, 907, 931, 1,
		0, 0, 0, 908, 909, 5, 18, 0, 0, 909, 911, 3, 104, 52, 0, 910, 912, 5, 69,
		0, 0, 911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0,
		913, 914, 6, 49, -1, 0, 914, 931, 1, 0, 0, 0, 915, 917, 5, 18, 0, 0, 916,
		918, 5, 69, 0, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 919,
		1, 0, 0, 0, 919, 931, 6, 49, -1, 0, 920, 922, 5, 17, 0, 0, 921, 923, 5,
		69, 0, 0, 922, 921, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 924, 1, 0, 0,
		0, 924, 931, 6, 49, -1, 0, 925, 927, 5, 16, 0, 0, 926, 928, 5, 69, 0, 0,
		927, 926, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929,
		931, 6, 49, -1, 0, 930, 801, 1, 0, 0, 0, 930, 807, 1, 0, 0, 0, 930, 813,
		1, 0, 0, 0, 930, 816, 1, 0, 0, 0, 930, 819, 1, 0, 0, 0, 930, 822, 1, 0,
		0, 0, 930, 825, 1, 0, 0, 0, 930, 830, 1, 0, 0, 0, 930, 840, 1, 0, 0, 0,
		930, 848, 1, 0, 0, 0, 930, 854, 1, 0, 0, 0, 930, 862, 1, 0, 0, 0, 930,
		870, 1, 0, 0, 0, 930, 876, 1, 0, 0, 0, 930, 884, 1, 0, 0, 0, 930, 894,
		1, 0, 0, 0, 930, 902, 1, 0, 0, 0, 930, 908, 1, 0, 0, 0, 930, 915, 1, 0,
		0, 0, 930, 920, 1, 0, 0, 0, 930, 925, 1, 0, 0, 0, 931, 99, 1, 0, 0, 0,
		932, 933, 5, 3, 0, 0, 933, 943, 6, 50, -1, 0, 934, 935, 5, 1, 0, 0, 935,
		943, 6, 50, -1, 0, 936, 937, 5, 4, 0, 0, 937, 943, 6, 50, -1, 0, 938, 939,
		5, 5, 0, 0, 939, 943, 6, 50, -1, 0, 940, 941, 5, 2, 0, 0, 941, 943, 6,
		50, -1, 0, 942, 932, 1, 0, 0, 0, 942, 934, 1, 0, 0, 0, 942, 936, 1, 0,
		0, 0, 942, 938, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 943, 101, 1, 0, 0, 0,
		944, 945, 3, 100, 50, 0, 945, 946, 6, 51, -1, 0, 946, 950, 1, 0, 0, 0,
		947, 948, 5, 42, 0, 0, 948, 950, 6, 51, -1, 0, 949, 944, 1, 0, 0, 0, 949,
		947, 1, 0, 0, 0, 950, 103, 1, 0, 0, 0, 951, 952, 6, 52, -1, 0, 952, 953,
		5, 42, 0, 0, 953, 954, 3, 74, 37, 0, 954, 955, 6, 52, -1, 0, 955, 1010,
		1, 0, 0, 0, 956, 957, 5, 46, 0, 0, 957, 958, 3, 104, 52, 21, 958, 959,
		6, 52, -1, 0, 959, 1010, 1, 0, 0, 0, 960, 961, 5, 59, 0, 0, 961, 962, 3,
		104, 52, 15, 962, 963, 6, 52, -1, 0, 963, 1010, 1, 0, 0, 0, 964, 965, 3,
		100, 50, 0, 965, 966, 5, 60, 0, 0, 966, 967, 3, 104, 52, 0, 967, 968, 5,
		61, 0, 0, 968, 969, 6, 52, -1, 0, 969, 1010, 1, 0, 0, 0, 970, 971, 5, 34,
		0, 0, 971, 973, 5, 66, 0, 0, 972, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0,
		973, 974, 1, 0, 0, 0, 974, 975, 3, 86, 43, 0, 975, 976, 6, 52, -1, 0, 976,
		1010, 1, 0, 0, 0, 977, 978, 5, 34, 0, 0, 978, 980, 5, 66, 0, 0, 979, 977,
		1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 982, 3, 6,
		3, 0, 982, 983, 6, 52, -1, 0, 983, 1010, 1, 0, 0, 0, 984, 985, 5, 34, 0,
		0, 985, 987, 5, 66, 0, 0, 986, 984, 1, 0, 0, 0, 986, 987, 1, 0, 0, 0, 987,
		988, 1, 0, 0, 0, 988, 989, 5, 42, 0, 0, 989, 1010, 6, 52, -1, 0, 990, 991,
		5, 21, 0, 0, 991, 1010, 6, 52, -1, 0, 992, 993, 5, 39, 0, 0, 993, 1010,
		6, 52, -1, 0, 994, 995, 5, 38, 0, 0, 995, 1010, 6, 52, -1, 0, 996, 997,
		5, 40, 0, 0, 997, 1010, 6, 52, -1, 0, 998, 999, 5, 41, 0, 0, 999, 1010,
		6, 52, -1, 0, 1000, 1001, 5, 19, 0, 0, 1001, 1010, 6, 52, -1, 0, 1002,
		1003, 5, 20, 0, 0, 1003, 1010, 6, 52, -1, 0, 1004, 1005, 5, 60, 0, 0, 1005,
		1006, 3, 104, 52, 0, 1006, 1007, 5, 61, 0, 0, 1007, 1008, 6, 52, -1, 0,
		1008, 1010, 1, 0, 0, 0, 1009, 951, 1, 0, 0, 0, 1009, 956, 1, 0, 0, 0, 1009,
		960, 1, 0, 0, 0, 1009, 964, 1, 0, 0, 0, 1009, 972, 1, 0, 0, 0, 1009, 979,
		1, 0, 0, 0, 1009, 986, 1, 0, 0, 0, 1009, 990, 1, 0, 0, 0, 1009, 992, 1,
		0, 0, 0, 1009, 994, 1, 0, 0, 0, 1009, 996, 1, 0, 0, 0, 1009, 998, 1, 0,
		0, 0, 1009, 1000, 1, 0, 0, 0, 1009, 1002, 1, 0, 0, 0, 1009, 1004, 1, 0,
		0, 0, 1010, 1056, 1, 0, 0, 0, 1011, 1012, 10, 20, 0, 0, 1012, 1013, 7,
		3, 0, 0, 1013, 1014, 3, 104, 52, 21, 1014, 1015, 6, 52, -1, 0, 1015, 1055,
		1, 0, 0, 0, 1016, 1017, 10, 19, 0, 0, 1017, 1018, 7, 4, 0, 0, 1018, 1019,
		3, 104, 52, 20, 1019, 1020, 6, 52, -1, 0, 1020, 1055, 1, 0, 0, 0, 1021,
		1022, 10, 18, 0, 0, 1022, 1023, 7, 5, 0, 0, 1023, 1024, 3, 104, 52, 19,
		1024, 1025, 6, 52, -1, 0, 1025, 1055, 1, 0, 0, 0, 1026, 1027, 10, 17, 0,
		0, 1027, 1028, 7, 6, 0, 0, 1028, 1029, 3, 104, 52, 18, 1029, 1030, 6, 52,
		-1, 0, 1030, 1055, 1, 0, 0, 0, 1031, 1032, 10, 16, 0, 0, 1032, 1033, 7,
		7, 0, 0, 1033, 1034, 3, 104, 52, 17, 1034, 1035, 6, 52, -1, 0, 1035, 1055,
		1, 0, 0, 0, 1036, 1037, 10, 14, 0, 0, 1037, 1038, 5, 57, 0, 0, 1038, 1039,
		3, 104, 52, 15, 1039, 1040, 6, 52, -1, 0, 1040, 1055, 1, 0, 0, 0, 1041,
		1042, 10, 13, 0, 0, 1042, 1043, 5, 58, 0, 0, 1043, 1044, 3, 104, 52, 14,
		1044, 1045, 6, 52, -1, 0, 1045, 1055, 1, 0, 0, 0, 1046, 1047, 10, 23, 0,
		0, 1047, 1048, 5, 66, 0, 0, 1048, 1049, 5, 29, 0, 0, 1049, 1055, 6, 52,
		-1, 0, 1050, 1051, 10, 22, 0, 0, 1051, 1052, 5, 66, 0, 0, 1052, 1053, 5,
		30, 0, 0, 1053, 1055, 6, 52, -1, 0, 1054, 1011, 1, 0, 0, 0, 1054, 1016,
		1, 0, 0, 0, 1054, 1021, 1, 0, 0, 0, 1054, 1026, 1, 0, 0, 0, 1054, 1031,
		1, 0, 0, 0, 1054, 1036, 1, 0, 0, 0, 1054, 1041, 1, 0, 0, 0, 1054, 1046,
		1, 0, 0, 0, 1054, 1050, 1, 0, 0, 0, 1055, 1058, 1, 0, 0, 0, 1056, 1054,
		1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 105, 1, 0, 0, 0, 1058, 1056,
		1, 0, 0, 0, 79, 112, 124, 135, 139, 151, 164, 185, 208, 224, 260, 273,
		324, 332, 353, 368, 380, 392, 406, 416, 432, 494, 513, 526, 553, 569, 577,
		595, 606, 632, 644, 666, 678, 682, 687, 694, 698, 701, 704, 710, 716, 723,
		729, 740, 749, 757, 764, 776, 786, 798, 803, 809, 830, 834, 840, 844, 850,
		856, 862, 866, 872, 878, 884, 888, 894, 898, 904, 911, 917, 922, 927, 930,
		942, 949, 972, 979, 986, 1009, 1054, 1056,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ParserParserInit initializes any static state used to implement ParserParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewParserParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ParserParserInit() {
	staticData := &ParserParserStaticData
	staticData.once.Do(parserParserInit)
}

// NewParserParser produces a new parser instance for the optional input antlr.TokenStream.
func NewParserParser(input antlr.TokenStream) *ParserParser {
	ParserParserInit()
	this := new(ParserParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Parser.g4"

	return this
}

// ParserParser tokens.
const (
	ParserParserEOF           = antlr.TokenEOF
	ParserParserRW_Int        = 1
	ParserParserRW_Float      = 2
	ParserParserRW_String     = 3
	ParserParserRW_Bool       = 4
	ParserParserRW_Character  = 5
	ParserParserRW_var        = 6
	ParserParserRW_let        = 7
	ParserParserRW_if         = 8
	ParserParserRW_else       = 9
	ParserParserRW_for        = 10
	ParserParserRW_while      = 11
	ParserParserRW_guard      = 12
	ParserParserRW_switch     = 13
	ParserParserRW_case       = 14
	ParserParserRW_default    = 15
	ParserParserRW_break      = 16
	ParserParserRW_continue   = 17
	ParserParserRW_return     = 18
	ParserParserRW_true       = 19
	ParserParserRW_false      = 20
	ParserParserRW_nil        = 21
	ParserParserRW_func       = 22
	ParserParserRW_inout      = 23
	ParserParserRW_in         = 24
	ParserParserRW_append     = 25
	ParserParserRW_removeLast = 26
	ParserParserRW_remove     = 27
	ParserParserRW_at         = 28
	ParserParserRW_isEmpty    = 29
	ParserParserRW_count      = 30
	ParserParserRW_repeating  = 31
	ParserParserRW_struct     = 32
	ParserParserRW_mutating   = 33
	ParserParserRW_self       = 34
	ParserParserRW_print      = 35
	ParserParserTK_prompt     = 36
	ParserParserTK_under      = 37
	ParserParserTK_char       = 38
	ParserParserTK_string     = 39
	ParserParserTK_int        = 40
	ParserParserTK_float      = 41
	ParserParserTK_id         = 42
	ParserParserTK_add        = 43
	ParserParserTK_sub        = 44
	ParserParserTK_plus       = 45
	ParserParserTK_minus      = 46
	ParserParserTK_mult       = 47
	ParserParserTK_div        = 48
	ParserParserTK_mod        = 49
	ParserParserTK_equequ     = 50
	ParserParserTK_notequ     = 51
	ParserParserTK_lessequ    = 52
	ParserParserTK_moreequ    = 53
	ParserParserTK_equ        = 54
	ParserParserTK_less       = 55
	ParserParserTK_more       = 56
	ParserParserTK_and        = 57
	ParserParserTK_or         = 58
	ParserParserTK_not        = 59
	ParserParserTK_lpar       = 60
	ParserParserTK_rpar       = 61
	ParserParserTK_lbrc       = 62
	ParserParserTK_rbrc       = 63
	ParserParserTK_lbrk       = 64
	ParserParserTK_rbrk       = 65
	ParserParserTK_dot        = 66
	ParserParserTK_comma      = 67
	ParserParserTK_colon      = 68
	ParserParserTK_semicolon  = 69
	ParserParserTK_question   = 70
	ParserParserTK_amp        = 71
	ParserParserNEWLINE       = 72
	ParserParserUNUSED_       = 73
	ParserParserCOMMENTS_     = 74
	ParserParserCOMMENTM_     = 75
	ParserParserERROR         = 76
)

// ParserParser rules.
const (
	ParserParserRULE_init          = 0
	ParserParserRULE_instsglobal   = 1
	ParserParserRULE_instglobal    = 2
	ParserParserRULE_callfunc      = 3
	ParserParserRULE_listargs      = 4
	ParserParserRULE_arg           = 5
	ParserParserRULE_decvar        = 6
	ParserParserRULE_deccst        = 7
	ParserParserRULE_declfunc      = 8
	ParserParserRULE_listparams    = 9
	ParserParserRULE_param         = 10
	ParserParserRULE_typeparam     = 11
	ParserParserRULE_ifstruct      = 12
	ParserParserRULE_switchstruct  = 13
	ParserParserRULE_envs          = 14
	ParserParserRULE_casesdefault  = 15
	ParserParserRULE_cases         = 16
	ParserParserRULE_case          = 17
	ParserParserRULE_default       = 18
	ParserParserRULE_loopfor       = 19
	ParserParserRULE_range         = 20
	ParserParserRULE_loopwhile     = 21
	ParserParserRULE_guard         = 22
	ParserParserRULE_reasign       = 23
	ParserParserRULE_addsub        = 24
	ParserParserRULE_decvector     = 25
	ParserParserRULE_defvector     = 26
	ParserParserRULE_listexp       = 27
	ParserParserRULE_funcvector    = 28
	ParserParserRULE_decmatrix     = 29
	ParserParserRULE_defmatrix     = 30
	ParserParserRULE_matrix        = 31
	ParserParserRULE_vectors       = 32
	ParserParserRULE_vector        = 33
	ParserParserRULE_simplematrix  = 34
	ParserParserRULE_typematrix    = 35
	ParserParserRULE_reasignvector = 36
	ParserParserRULE_dims          = 37
	ParserParserRULE_defstruct     = 38
	ParserParserRULE_listattribs   = 39
	ParserParserRULE_attrib        = 40
	ParserParserRULE_decstruct     = 41
	ParserParserRULE_listdupla     = 42
	ParserParserRULE_useattribs    = 43
	ParserParserRULE_obj           = 44
	ParserParserRULE_useattribs1   = 45
	ParserParserRULE_print         = 46
	ParserParserRULE_env           = 47
	ParserParserRULE_instructions  = 48
	ParserParserRULE_instruction   = 49
	ParserParserRULE_type          = 50
	ParserParserRULE_typeComp      = 51
	ParserParserRULE_exp           = 52
)

// IInitContext is an interface to support dynamic dispatch.
type IInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInsts returns the insts rule contexts.
	GetInsts() IInstsglobalContext

	// SetInsts sets the insts rule contexts.
	SetInsts(IInstsglobalContext)

	// GetResult returns the result attribute.
	GetResult() []interface{}

	// SetResult sets the result attribute.
	SetResult([]interface{})

	// Getter signatures
	EOF() antlr.TerminalNode
	Instsglobal() IInstsglobalContext

	// IsInitContext differentiates from other interfaces.
	IsInitContext()
}

type InitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interface{}
	insts  IInstsglobalContext
}

func NewEmptyInitContext() *InitContext {
	var p = new(InitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_init
	return p
}

func InitEmptyInitContext(p *InitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_init
}

func (*InitContext) IsInitContext() {}

func NewInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitContext {
	var p = new(InitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_init

	return p
}

func (s *InitContext) GetParser() antlr.Parser { return s.parser }

func (s *InitContext) GetInsts() IInstsglobalContext { return s.insts }

func (s *InitContext) SetInsts(v IInstsglobalContext) { s.insts = v }

func (s *InitContext) GetResult() []interface{} { return s.result }

func (s *InitContext) SetResult(v []interface{}) { s.result = v }

func (s *InitContext) EOF() antlr.TerminalNode {
	return s.GetToken(ParserParserEOF, 0)
}

func (s *InitContext) Instsglobal() IInstsglobalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstsglobalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstsglobalContext)
}

func (s *InitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterInit(s)
	}
}

func (s *InitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitInit(s)
	}
}

func (p *ParserParser) Init() (localctx IInitContext) {
	localctx = NewInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ParserParserRULE_init)
	p.SetState(112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_var, ParserParserRW_let, ParserParserRW_if, ParserParserRW_for, ParserParserRW_while, ParserParserRW_guard, ParserParserRW_switch, ParserParserRW_break, ParserParserRW_continue, ParserParserRW_return, ParserParserRW_func, ParserParserRW_struct, ParserParserRW_self, ParserParserRW_print, ParserParserTK_id:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(106)

			var _x = p.instsglobal(0)

			localctx.(*InitContext).insts = _x
		}
		{
			p.SetState(107)
			p.Match(ParserParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*InitContext).result = localctx.(*InitContext).GetInsts().GetResult()

	case ParserParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(110)
			p.Match(ParserParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*InitContext).result = []interface{}{}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstsglobalContext is an interface to support dynamic dispatch.
type IInstsglobalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IInstsglobalContext

	// GetI returns the i rule contexts.
	GetI() IInstglobalContext

	// SetL sets the l rule contexts.
	SetL(IInstsglobalContext)

	// SetI sets the i rule contexts.
	SetI(IInstglobalContext)

	// GetResult returns the result attribute.
	GetResult() []interface{}

	// SetResult sets the result attribute.
	SetResult([]interface{})

	// Getter signatures
	Instglobal() IInstglobalContext
	Instsglobal() IInstsglobalContext

	// IsInstsglobalContext differentiates from other interfaces.
	IsInstsglobalContext()
}

type InstsglobalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interface{}
	l      IInstsglobalContext
	i      IInstglobalContext
}

func NewEmptyInstsglobalContext() *InstsglobalContext {
	var p = new(InstsglobalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instsglobal
	return p
}

func InitEmptyInstsglobalContext(p *InstsglobalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instsglobal
}

func (*InstsglobalContext) IsInstsglobalContext() {}

func NewInstsglobalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstsglobalContext {
	var p = new(InstsglobalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_instsglobal

	return p
}

func (s *InstsglobalContext) GetParser() antlr.Parser { return s.parser }

func (s *InstsglobalContext) GetL() IInstsglobalContext { return s.l }

func (s *InstsglobalContext) GetI() IInstglobalContext { return s.i }

func (s *InstsglobalContext) SetL(v IInstsglobalContext) { s.l = v }

func (s *InstsglobalContext) SetI(v IInstglobalContext) { s.i = v }

func (s *InstsglobalContext) GetResult() []interface{} { return s.result }

func (s *InstsglobalContext) SetResult(v []interface{}) { s.result = v }

func (s *InstsglobalContext) Instglobal() IInstglobalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstglobalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstglobalContext)
}

func (s *InstsglobalContext) Instsglobal() IInstsglobalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstsglobalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstsglobalContext)
}

func (s *InstsglobalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstsglobalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstsglobalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterInstsglobal(s)
	}
}

func (s *InstsglobalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitInstsglobal(s)
	}
}

func (p *ParserParser) Instsglobal() (localctx IInstsglobalContext) {
	return p.instsglobal(0)
}

func (p *ParserParser) instsglobal(_p int) (localctx IInstsglobalContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewInstsglobalContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInstsglobalContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 2
	p.EnterRecursionRule(localctx, 2, ParserParserRULE_instsglobal, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(115)

		var _x = p.Instglobal()

		localctx.(*InstsglobalContext).i = _x
	}
	localctx.(*InstsglobalContext).result = []interface{}{localctx.(*InstsglobalContext).GetI().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInstsglobalContext(p, _parentctx, _parentState)
			localctx.(*InstsglobalContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_instsglobal)
			p.SetState(118)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(119)

				var _x = p.Instglobal()

				localctx.(*InstsglobalContext).i = _x
			}
			localctx.(*InstsglobalContext).SetResult(localctx.(*InstsglobalContext).GetL().GetResult())
			localctx.(*InstsglobalContext).result = append(localctx.(*InstsglobalContext).result, localctx.(*InstsglobalContext).GetI().GetResult())

		}
		p.SetState(126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstglobalContext is an interface to support dynamic dispatch.
type IInstglobalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInst0 returns the inst0 rule contexts.
	GetInst0() IInstructionContext

	// GetInst1 returns the inst1 rule contexts.
	GetInst1() IDeclfuncContext

	// GetInst2 returns the inst2 rule contexts.
	GetInst2() IDefstructContext

	// SetInst0 sets the inst0 rule contexts.
	SetInst0(IInstructionContext)

	// SetInst1 sets the inst1 rule contexts.
	SetInst1(IDeclfuncContext)

	// SetInst2 sets the inst2 rule contexts.
	SetInst2(IDefstructContext)

	// GetResult returns the result attribute.
	GetResult() interface{}

	// SetResult sets the result attribute.
	SetResult(interface{})

	// Getter signatures
	Instruction() IInstructionContext
	Declfunc() IDeclfuncContext
	Defstruct() IDefstructContext
	TK_semicolon() antlr.TerminalNode

	// IsInstglobalContext differentiates from other interfaces.
	IsInstglobalContext()
}

type InstglobalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interface{}
	inst0  IInstructionContext
	inst1  IDeclfuncContext
	inst2  IDefstructContext
}

func NewEmptyInstglobalContext() *InstglobalContext {
	var p = new(InstglobalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instglobal
	return p
}

func InitEmptyInstglobalContext(p *InstglobalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instglobal
}

func (*InstglobalContext) IsInstglobalContext() {}

func NewInstglobalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstglobalContext {
	var p = new(InstglobalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_instglobal

	return p
}

func (s *InstglobalContext) GetParser() antlr.Parser { return s.parser }

func (s *InstglobalContext) GetInst0() IInstructionContext { return s.inst0 }

func (s *InstglobalContext) GetInst1() IDeclfuncContext { return s.inst1 }

func (s *InstglobalContext) GetInst2() IDefstructContext { return s.inst2 }

func (s *InstglobalContext) SetInst0(v IInstructionContext) { s.inst0 = v }

func (s *InstglobalContext) SetInst1(v IDeclfuncContext) { s.inst1 = v }

func (s *InstglobalContext) SetInst2(v IDefstructContext) { s.inst2 = v }

func (s *InstglobalContext) GetResult() interface{} { return s.result }

func (s *InstglobalContext) SetResult(v interface{}) { s.result = v }

func (s *InstglobalContext) Instruction() IInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *InstglobalContext) Declfunc() IDeclfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclfuncContext)
}

func (s *InstglobalContext) Defstruct() IDefstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefstructContext)
}

func (s *InstglobalContext) TK_semicolon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_semicolon, 0)
}

func (s *InstglobalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstglobalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstglobalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterInstglobal(s)
	}
}

func (s *InstglobalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitInstglobal(s)
	}
}

func (p *ParserParser) Instglobal() (localctx IInstglobalContext) {
	localctx = NewInstglobalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ParserParserRULE_instglobal)
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_var, ParserParserRW_let, ParserParserRW_if, ParserParserRW_for, ParserParserRW_while, ParserParserRW_guard, ParserParserRW_switch, ParserParserRW_break, ParserParserRW_continue, ParserParserRW_return, ParserParserRW_self, ParserParserRW_print, ParserParserTK_id:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(127)

			var _x = p.Instruction()

			localctx.(*InstglobalContext).inst0 = _x
		}
		localctx.(*InstglobalContext).result = localctx.(*InstglobalContext).GetInst0().GetResult()

	case ParserParserRW_func:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(130)

			var _x = p.Declfunc()

			localctx.(*InstglobalContext).inst1 = _x
		}
		localctx.(*InstglobalContext).result = localctx.(*InstglobalContext).GetInst1().GetResult()

	case ParserParserRW_struct:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(133)

			var _x = p.Defstruct()

			localctx.(*InstglobalContext).inst2 = _x
		}
		p.SetState(135)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(134)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstglobalContext).result = localctx.(*InstglobalContext).GetInst2().GetResult()

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallfuncContext is an interface to support dynamic dispatch.
type ICallfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetL returns the l rule contexts.
	GetL() IListargsContext

	// SetL sets the l rule contexts.
	SetL(IListargsContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Expression

	// SetResult sets the result attribute.
	SetResult(interfaces.Expression)

	// Getter signatures
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Listargs() IListargsContext

	// IsCallfuncContext differentiates from other interfaces.
	IsCallfuncContext()
}

type CallfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Expression
	id     antlr.Token
	l      IListargsContext
}

func NewEmptyCallfuncContext() *CallfuncContext {
	var p = new(CallfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_callfunc
	return p
}

func InitEmptyCallfuncContext(p *CallfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_callfunc
}

func (*CallfuncContext) IsCallfuncContext() {}

func NewCallfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallfuncContext {
	var p = new(CallfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_callfunc

	return p
}

func (s *CallfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *CallfuncContext) GetId() antlr.Token { return s.id }

func (s *CallfuncContext) SetId(v antlr.Token) { s.id = v }

func (s *CallfuncContext) GetL() IListargsContext { return s.l }

func (s *CallfuncContext) SetL(v IListargsContext) { s.l = v }

func (s *CallfuncContext) GetResult() interfaces.Expression { return s.result }

func (s *CallfuncContext) SetResult(v interfaces.Expression) { s.result = v }

func (s *CallfuncContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *CallfuncContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *CallfuncContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *CallfuncContext) Listargs() IListargsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListargsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListargsContext)
}

func (s *CallfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterCallfunc(s)
	}
}

func (s *CallfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitCallfunc(s)
	}
}

func (p *ParserParser) Callfunc() (localctx ICallfuncContext) {
	localctx = NewCallfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ParserParserRULE_callfunc)
	p.SetState(151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(141)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*CallfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(142)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(143)

			var _x = p.listargs(0)

			localctx.(*CallfuncContext).l = _x
		}
		{
			p.SetState(144)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CallfuncContext).result = expressions.NewCallFunction((func() int {
			if localctx.(*CallfuncContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*CallfuncContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallfuncContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*CallfuncContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*CallfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*CallfuncContext).GetId().GetText()
			}
		}()), localctx.(*CallfuncContext).GetL().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(147)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*CallfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(148)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(149)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CallfuncContext).result = expressions.NewCallFunction((func() int {
			if localctx.(*CallfuncContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*CallfuncContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*CallfuncContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*CallfuncContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*CallfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*CallfuncContext).GetId().GetText()
			}
		}()), []utils.Arg{})

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListargsContext is an interface to support dynamic dispatch.
type IListargsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListargsContext

	// GetA returns the a rule contexts.
	GetA() IArgContext

	// SetL sets the l rule contexts.
	SetL(IListargsContext)

	// SetA sets the a rule contexts.
	SetA(IArgContext)

	// GetResult returns the result attribute.
	GetResult() []utils.Arg

	// SetResult sets the result attribute.
	SetResult([]utils.Arg)

	// Getter signatures
	Arg() IArgContext
	TK_comma() antlr.TerminalNode
	Listargs() IListargsContext

	// IsListargsContext differentiates from other interfaces.
	IsListargsContext()
}

type ListargsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []utils.Arg
	l      IListargsContext
	a      IArgContext
}

func NewEmptyListargsContext() *ListargsContext {
	var p = new(ListargsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listargs
	return p
}

func InitEmptyListargsContext(p *ListargsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listargs
}

func (*ListargsContext) IsListargsContext() {}

func NewListargsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListargsContext {
	var p = new(ListargsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_listargs

	return p
}

func (s *ListargsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListargsContext) GetL() IListargsContext { return s.l }

func (s *ListargsContext) GetA() IArgContext { return s.a }

func (s *ListargsContext) SetL(v IListargsContext) { s.l = v }

func (s *ListargsContext) SetA(v IArgContext) { s.a = v }

func (s *ListargsContext) GetResult() []utils.Arg { return s.result }

func (s *ListargsContext) SetResult(v []utils.Arg) { s.result = v }

func (s *ListargsContext) Arg() IArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgContext)
}

func (s *ListargsContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *ListargsContext) Listargs() IListargsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListargsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListargsContext)
}

func (s *ListargsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListargsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListargsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterListargs(s)
	}
}

func (s *ListargsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitListargs(s)
	}
}

func (p *ParserParser) Listargs() (localctx IListargsContext) {
	return p.listargs(0)
}

func (p *ParserParser) listargs(_p int) (localctx IListargsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListargsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListargsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 8
	p.EnterRecursionRule(localctx, 8, ParserParserRULE_listargs, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)

		var _x = p.Arg()

		localctx.(*ListargsContext).a = _x
	}
	localctx.(*ListargsContext).result = []utils.Arg{localctx.(*ListargsContext).GetA().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListargsContext(p, _parentctx, _parentState)
			localctx.(*ListargsContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_listargs)
			p.SetState(157)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(158)
				p.Match(ParserParserTK_comma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(159)

				var _x = p.Arg()

				localctx.(*ListargsContext).a = _x
			}
			localctx.(*ListargsContext).SetResult(localctx.(*ListargsContext).GetL().GetResult())
			localctx.(*ListargsContext).result = append(localctx.(*ListargsContext).result, localctx.(*ListargsContext).GetA().GetResult())

		}
		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgContext is an interface to support dynamic dispatch.
type IArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// GetAm returns the am token.
	GetAm() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetAm sets the am token.
	SetAm(antlr.Token)

	// GetEp returns the ep rule contexts.
	GetEp() IExpContext

	// SetEp sets the ep rule contexts.
	SetEp(IExpContext)

	// GetResult returns the result attribute.
	GetResult() utils.Arg

	// SetResult sets the result attribute.
	SetResult(utils.Arg)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	TK_amp() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Exp() IExpContext

	// IsArgContext differentiates from other interfaces.
	IsArgContext()
}

type ArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result utils.Arg
	id     antlr.Token
	ep     IExpContext
	am     antlr.Token
}

func NewEmptyArgContext() *ArgContext {
	var p = new(ArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_arg
	return p
}

func InitEmptyArgContext(p *ArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_arg
}

func (*ArgContext) IsArgContext() {}

func NewArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgContext {
	var p = new(ArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_arg

	return p
}

func (s *ArgContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgContext) GetId() antlr.Token { return s.id }

func (s *ArgContext) GetAm() antlr.Token { return s.am }

func (s *ArgContext) SetId(v antlr.Token) { s.id = v }

func (s *ArgContext) SetAm(v antlr.Token) { s.am = v }

func (s *ArgContext) GetEp() IExpContext { return s.ep }

func (s *ArgContext) SetEp(v IExpContext) { s.ep = v }

func (s *ArgContext) GetResult() utils.Arg { return s.result }

func (s *ArgContext) SetResult(v utils.Arg) { s.result = v }

func (s *ArgContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *ArgContext) TK_amp() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_amp, 0)
}

func (s *ArgContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ArgContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterArg(s)
	}
}

func (s *ArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitArg(s)
	}
}

func (p *ParserParser) Arg() (localctx IArgContext) {
	localctx = NewArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ParserParserRULE_arg)
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(167)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ArgContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(168)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(169)
			p.Match(ParserParserTK_amp)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(170)

			var _x = p.exp(0)

			localctx.(*ArgContext).ep = _x
		}
		localctx.(*ArgContext).result = *utils.NewArg((func() int {
			if localctx.(*ArgContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ArgContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ArgContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ArgContext).GetId().GetText()
			}
		}()), localctx.(*ArgContext).GetEp().GetResult(), true)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(173)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ArgContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(174)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(175)

			var _x = p.exp(0)

			localctx.(*ArgContext).ep = _x
		}
		localctx.(*ArgContext).result = *utils.NewArg((func() int {
			if localctx.(*ArgContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ArgContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ArgContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ArgContext).GetId().GetText()
			}
		}()), localctx.(*ArgContext).GetEp().GetResult(), false)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(178)

			var _m = p.Match(ParserParserTK_amp)

			localctx.(*ArgContext).am = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(179)

			var _x = p.exp(0)

			localctx.(*ArgContext).ep = _x
		}
		localctx.(*ArgContext).result = *utils.NewArg((func() int {
			if localctx.(*ArgContext).GetAm() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetAm().GetLine()
			}
		}()), (func() int {
			if localctx.(*ArgContext).GetAm() == nil {
				return 0
			} else {
				return localctx.(*ArgContext).GetAm().GetColumn()
			}
		}()), "_", localctx.(*ArgContext).GetEp().GetResult(), true)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(182)

			var _x = p.exp(0)

			localctx.(*ArgContext).ep = _x
		}
		localctx.(*ArgContext).result = *utils.NewArg(localctx.(*ArgContext).GetEp().GetResult().LineN(), localctx.(*ArgContext).GetEp().GetResult().ColumnN(), "_", localctx.(*ArgContext).GetEp().GetResult(), false)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecvarContext is an interface to support dynamic dispatch.
type IDecvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypeContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetT sets the t rule contexts.
	SetT(ITypeContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	TK_equ() antlr.TerminalNode
	RW_var() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Type_() ITypeContext
	Exp() IExpContext
	TK_question() antlr.TerminalNode

	// IsDecvarContext differentiates from other interfaces.
	IsDecvarContext()
}

type DecvarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	d      antlr.Token
	id     antlr.Token
	t      ITypeContext
	e      IExpContext
}

func NewEmptyDecvarContext() *DecvarContext {
	var p = new(DecvarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decvar
	return p
}

func InitEmptyDecvarContext(p *DecvarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decvar
}

func (*DecvarContext) IsDecvarContext() {}

func NewDecvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecvarContext {
	var p = new(DecvarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_decvar

	return p
}

func (s *DecvarContext) GetParser() antlr.Parser { return s.parser }

func (s *DecvarContext) GetD() antlr.Token { return s.d }

func (s *DecvarContext) GetId() antlr.Token { return s.id }

func (s *DecvarContext) SetD(v antlr.Token) { s.d = v }

func (s *DecvarContext) SetId(v antlr.Token) { s.id = v }

func (s *DecvarContext) GetT() ITypeContext { return s.t }

func (s *DecvarContext) GetE() IExpContext { return s.e }

func (s *DecvarContext) SetT(v ITypeContext) { s.t = v }

func (s *DecvarContext) SetE(v IExpContext) { s.e = v }

func (s *DecvarContext) GetResult() interfaces.Instruction { return s.result }

func (s *DecvarContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DecvarContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DecvarContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *DecvarContext) RW_var() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_var, 0)
}

func (s *DecvarContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DecvarContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *DecvarContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *DecvarContext) TK_question() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_question, 0)
}

func (s *DecvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDecvar(s)
	}
}

func (s *DecvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDecvar(s)
	}
}

func (p *ParserParser) Decvar() (localctx IDecvarContext) {
	localctx = NewDecvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ParserParserRULE_decvar)
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(187)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecvarContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvarContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(189)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(190)

			var _x = p.Type_()

			localctx.(*DecvarContext).t = _x
		}
		{
			p.SetState(191)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(192)

			var _x = p.exp(0)

			localctx.(*DecvarContext).e = _x
		}
		localctx.(*DecvarContext).result = instructions.NewInitID((func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecvarContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvarContext).GetId().GetText()
			}
		}()), localctx.(*DecvarContext).GetT().GetResult().Value.(utils.Type), localctx.(*DecvarContext).GetE().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(195)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecvarContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvarContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(197)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(198)

			var _x = p.Type_()

			localctx.(*DecvarContext).t = _x
		}
		{
			p.SetState(199)
			p.Match(ParserParserTK_question)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DecvarContext).result = instructions.NewInitID((func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecvarContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvarContext).GetId().GetText()
			}
		}()), localctx.(*DecvarContext).GetT().GetResult().Value.(utils.Type), nil)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(202)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecvarContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(203)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvarContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(204)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(205)

			var _x = p.exp(0)

			localctx.(*DecvarContext).e = _x
		}
		localctx.(*DecvarContext).result = instructions.NewInitID((func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvarContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvarContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecvarContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvarContext).GetId().GetText()
			}
		}()), utils.NIL, localctx.(*DecvarContext).GetE().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeccstContext is an interface to support dynamic dispatch.
type IDeccstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypeContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetT sets the t rule contexts.
	SetT(ITypeContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	TK_equ() antlr.TerminalNode
	RW_let() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Type_() ITypeContext
	Exp() IExpContext

	// IsDeccstContext differentiates from other interfaces.
	IsDeccstContext()
}

type DeccstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	d      antlr.Token
	id     antlr.Token
	t      ITypeContext
	e      IExpContext
}

func NewEmptyDeccstContext() *DeccstContext {
	var p = new(DeccstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_deccst
	return p
}

func InitEmptyDeccstContext(p *DeccstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_deccst
}

func (*DeccstContext) IsDeccstContext() {}

func NewDeccstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeccstContext {
	var p = new(DeccstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_deccst

	return p
}

func (s *DeccstContext) GetParser() antlr.Parser { return s.parser }

func (s *DeccstContext) GetD() antlr.Token { return s.d }

func (s *DeccstContext) GetId() antlr.Token { return s.id }

func (s *DeccstContext) SetD(v antlr.Token) { s.d = v }

func (s *DeccstContext) SetId(v antlr.Token) { s.id = v }

func (s *DeccstContext) GetT() ITypeContext { return s.t }

func (s *DeccstContext) GetE() IExpContext { return s.e }

func (s *DeccstContext) SetT(v ITypeContext) { s.t = v }

func (s *DeccstContext) SetE(v IExpContext) { s.e = v }

func (s *DeccstContext) GetResult() interfaces.Instruction { return s.result }

func (s *DeccstContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DeccstContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DeccstContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *DeccstContext) RW_let() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_let, 0)
}

func (s *DeccstContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DeccstContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *DeccstContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *DeccstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeccstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeccstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDeccst(s)
	}
}

func (s *DeccstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDeccst(s)
	}
}

func (p *ParserParser) Deccst() (localctx IDeccstContext) {
	localctx = NewDeccstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ParserParserRULE_deccst)
	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(210)

			var _m = p.Match(ParserParserRW_let)

			localctx.(*DeccstContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(211)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeccstContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(212)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(213)

			var _x = p.Type_()

			localctx.(*DeccstContext).t = _x
		}
		{
			p.SetState(214)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(215)

			var _x = p.exp(0)

			localctx.(*DeccstContext).e = _x
		}
		localctx.(*DeccstContext).result = instructions.NewInitID((func() int {
			if localctx.(*DeccstContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DeccstContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeccstContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DeccstContext).GetD().GetColumn()
			}
		}()), false, (func() string {
			if localctx.(*DeccstContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeccstContext).GetId().GetText()
			}
		}()), localctx.(*DeccstContext).GetT().GetResult().Value.(utils.Type), localctx.(*DeccstContext).GetE().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(218)

			var _m = p.Match(ParserParserRW_let)

			localctx.(*DeccstContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(219)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeccstContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(220)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(221)

			var _x = p.exp(0)

			localctx.(*DeccstContext).e = _x
		}
		localctx.(*DeccstContext).result = instructions.NewInitID((func() int {
			if localctx.(*DeccstContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DeccstContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeccstContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DeccstContext).GetD().GetColumn()
			}
		}()), false, (func() string {
			if localctx.(*DeccstContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeccstContext).GetId().GetText()
			}
		}()), utils.NIL, localctx.(*DeccstContext).GetE().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclfuncContext is an interface to support dynamic dispatch.
type IDeclfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetF returns the f token.
	GetF() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetF sets the f token.
	SetF(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetL returns the l rule contexts.
	GetL() IListparamsContext

	// GetT returns the t rule contexts.
	GetT() ITypeCompContext

	// GetB returns the b rule contexts.
	GetB() IEnvContext

	// SetL sets the l rule contexts.
	SetL(IListparamsContext)

	// SetT sets the t rule contexts.
	SetT(ITypeCompContext)

	// SetB sets the b rule contexts.
	SetB(IEnvContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	TK_prompt() antlr.TerminalNode
	RW_func() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Listparams() IListparamsContext
	TypeComp() ITypeCompContext
	Env() IEnvContext

	// IsDeclfuncContext differentiates from other interfaces.
	IsDeclfuncContext()
}

type DeclfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	f      antlr.Token
	id     antlr.Token
	l      IListparamsContext
	t      ITypeCompContext
	b      IEnvContext
}

func NewEmptyDeclfuncContext() *DeclfuncContext {
	var p = new(DeclfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_declfunc
	return p
}

func InitEmptyDeclfuncContext(p *DeclfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_declfunc
}

func (*DeclfuncContext) IsDeclfuncContext() {}

func NewDeclfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclfuncContext {
	var p = new(DeclfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_declfunc

	return p
}

func (s *DeclfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclfuncContext) GetF() antlr.Token { return s.f }

func (s *DeclfuncContext) GetId() antlr.Token { return s.id }

func (s *DeclfuncContext) SetF(v antlr.Token) { s.f = v }

func (s *DeclfuncContext) SetId(v antlr.Token) { s.id = v }

func (s *DeclfuncContext) GetL() IListparamsContext { return s.l }

func (s *DeclfuncContext) GetT() ITypeCompContext { return s.t }

func (s *DeclfuncContext) GetB() IEnvContext { return s.b }

func (s *DeclfuncContext) SetL(v IListparamsContext) { s.l = v }

func (s *DeclfuncContext) SetT(v ITypeCompContext) { s.t = v }

func (s *DeclfuncContext) SetB(v IEnvContext) { s.b = v }

func (s *DeclfuncContext) GetResult() interfaces.Instruction { return s.result }

func (s *DeclfuncContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DeclfuncContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *DeclfuncContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *DeclfuncContext) TK_prompt() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_prompt, 0)
}

func (s *DeclfuncContext) RW_func() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_func, 0)
}

func (s *DeclfuncContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DeclfuncContext) Listparams() IListparamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListparamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListparamsContext)
}

func (s *DeclfuncContext) TypeComp() ITypeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCompContext)
}

func (s *DeclfuncContext) Env() IEnvContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvContext)
}

func (s *DeclfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDeclfunc(s)
	}
}

func (s *DeclfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDeclfunc(s)
	}
}

func (p *ParserParser) Declfunc() (localctx IDeclfuncContext) {
	localctx = NewDeclfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ParserParserRULE_declfunc)
	p.SetState(260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(226)

			var _m = p.Match(ParserParserRW_func)

			localctx.(*DeclfuncContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(227)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeclfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(228)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(229)

			var _x = p.listparams(0)

			localctx.(*DeclfuncContext).l = _x
		}
		{
			p.SetState(230)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(231)
			p.Match(ParserParserTK_prompt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)

			var _x = p.TypeComp()

			localctx.(*DeclfuncContext).t = _x
		}
		{
			p.SetState(233)

			var _x = p.Env()

			localctx.(*DeclfuncContext).b = _x
		}
		localctx.(*DeclfuncContext).result = instructions.NewFunction((func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclfuncContext).GetId().GetText()
			}
		}()), localctx.(*DeclfuncContext).GetL().GetResult(), localctx.(*DeclfuncContext).GetB().GetResult(), localctx.(*DeclfuncContext).GetT().GetResult().Value.(utils.Type))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(236)

			var _m = p.Match(ParserParserRW_func)

			localctx.(*DeclfuncContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(237)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeclfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(238)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(239)

			var _x = p.listparams(0)

			localctx.(*DeclfuncContext).l = _x
		}
		{
			p.SetState(240)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)

			var _x = p.Env()

			localctx.(*DeclfuncContext).b = _x
		}
		localctx.(*DeclfuncContext).result = instructions.NewFunction((func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclfuncContext).GetId().GetText()
			}
		}()), localctx.(*DeclfuncContext).GetL().GetResult(), localctx.(*DeclfuncContext).GetB().GetResult(), utils.NIL)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(244)

			var _m = p.Match(ParserParserRW_func)

			localctx.(*DeclfuncContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(245)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeclfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(247)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(248)
			p.Match(ParserParserTK_prompt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(249)

			var _x = p.TypeComp()

			localctx.(*DeclfuncContext).t = _x
		}
		{
			p.SetState(250)

			var _x = p.Env()

			localctx.(*DeclfuncContext).b = _x
		}
		localctx.(*DeclfuncContext).result = instructions.NewFunction((func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclfuncContext).GetId().GetText()
			}
		}()), []utils.Param{}, localctx.(*DeclfuncContext).GetB().GetResult(), localctx.(*DeclfuncContext).GetT().GetResult().Value.(utils.Type))

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(253)

			var _m = p.Match(ParserParserRW_func)

			localctx.(*DeclfuncContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(254)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DeclfuncContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(255)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(256)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(257)

			var _x = p.Env()

			localctx.(*DeclfuncContext).b = _x
		}
		localctx.(*DeclfuncContext).result = instructions.NewFunction((func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclfuncContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*DeclfuncContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclfuncContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DeclfuncContext).GetId().GetText()
			}
		}()), []utils.Param{}, localctx.(*DeclfuncContext).GetB().GetResult(), utils.NIL)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListparamsContext is an interface to support dynamic dispatch.
type IListparamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListparamsContext

	// GetP returns the p rule contexts.
	GetP() IParamContext

	// SetL sets the l rule contexts.
	SetL(IListparamsContext)

	// SetP sets the p rule contexts.
	SetP(IParamContext)

	// GetResult returns the result attribute.
	GetResult() []utils.Param

	// SetResult sets the result attribute.
	SetResult([]utils.Param)

	// Getter signatures
	Param() IParamContext
	TK_comma() antlr.TerminalNode
	Listparams() IListparamsContext

	// IsListparamsContext differentiates from other interfaces.
	IsListparamsContext()
}

type ListparamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []utils.Param
	l      IListparamsContext
	p      IParamContext
}

func NewEmptyListparamsContext() *ListparamsContext {
	var p = new(ListparamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listparams
	return p
}

func InitEmptyListparamsContext(p *ListparamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listparams
}

func (*ListparamsContext) IsListparamsContext() {}

func NewListparamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListparamsContext {
	var p = new(ListparamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_listparams

	return p
}

func (s *ListparamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListparamsContext) GetL() IListparamsContext { return s.l }

func (s *ListparamsContext) GetP() IParamContext { return s.p }

func (s *ListparamsContext) SetL(v IListparamsContext) { s.l = v }

func (s *ListparamsContext) SetP(v IParamContext) { s.p = v }

func (s *ListparamsContext) GetResult() []utils.Param { return s.result }

func (s *ListparamsContext) SetResult(v []utils.Param) { s.result = v }

func (s *ListparamsContext) Param() IParamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ListparamsContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *ListparamsContext) Listparams() IListparamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListparamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListparamsContext)
}

func (s *ListparamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListparamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListparamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterListparams(s)
	}
}

func (s *ListparamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitListparams(s)
	}
}

func (p *ParserParser) Listparams() (localctx IListparamsContext) {
	return p.listparams(0)
}

func (p *ParserParser) listparams(_p int) (localctx IListparamsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListparamsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListparamsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 18
	p.EnterRecursionRule(localctx, 18, ParserParserRULE_listparams, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(263)

		var _x = p.Param()

		localctx.(*ListparamsContext).p = _x
	}
	localctx.(*ListparamsContext).result = []utils.Param{localctx.(*ListparamsContext).GetP().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListparamsContext(p, _parentctx, _parentState)
			localctx.(*ListparamsContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_listparams)
			p.SetState(266)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(267)
				p.Match(ParserParserTK_comma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(268)

				var _x = p.Param()

				localctx.(*ListparamsContext).p = _x
			}
			localctx.(*ListparamsContext).SetResult(localctx.(*ListparamsContext).GetL().GetResult())
			localctx.(*ListparamsContext).result = append(localctx.(*ListparamsContext).result, localctx.(*ListparamsContext).GetP().GetResult())

		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExt returns the ext token.
	GetExt() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetExt sets the ext token.
	SetExt(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypeparamContext

	// SetT sets the t rule contexts.
	SetT(ITypeparamContext)

	// GetResult returns the result attribute.
	GetResult() utils.Param

	// SetResult sets the result attribute.
	SetResult(utils.Param)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	RW_inout() antlr.TerminalNode
	AllTK_id() []antlr.TerminalNode
	TK_id(i int) antlr.TerminalNode
	Typeparam() ITypeparamContext
	TK_under() antlr.TerminalNode

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result utils.Param
	ext    antlr.Token
	id     antlr.Token
	t      ITypeparamContext
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) GetExt() antlr.Token { return s.ext }

func (s *ParamContext) GetId() antlr.Token { return s.id }

func (s *ParamContext) SetExt(v antlr.Token) { s.ext = v }

func (s *ParamContext) SetId(v antlr.Token) { s.id = v }

func (s *ParamContext) GetT() ITypeparamContext { return s.t }

func (s *ParamContext) SetT(v ITypeparamContext) { s.t = v }

func (s *ParamContext) GetResult() utils.Param { return s.result }

func (s *ParamContext) SetResult(v utils.Param) { s.result = v }

func (s *ParamContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *ParamContext) RW_inout() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_inout, 0)
}

func (s *ParamContext) AllTK_id() []antlr.TerminalNode {
	return s.GetTokens(ParserParserTK_id)
}

func (s *ParamContext) TK_id(i int) antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, i)
}

func (s *ParamContext) Typeparam() ITypeparamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeparamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeparamContext)
}

func (s *ParamContext) TK_under() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_under, 0)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *ParserParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ParserParserRULE_param)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(276)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).ext = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(279)
			p.Match(ParserParserRW_inout)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(280)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetExt() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetExt().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), true, localctx.(*ParamContext).GetT().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(283)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(284)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(285)
			p.Match(ParserParserRW_inout)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(286)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), true, localctx.(*ParamContext).GetT().GetResult())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(289)

			var _m = p.Match(ParserParserTK_under)

			localctx.(*ParamContext).ext = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(290)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(291)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(292)
			p.Match(ParserParserRW_inout)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(293)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetExt() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetExt().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), true, localctx.(*ParamContext).GetT().GetResult())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(296)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(297)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(298)
			p.Match(ParserParserRW_inout)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(299)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), true, localctx.(*ParamContext).GetT().GetResult())

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(302)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).ext = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(304)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetExt() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetExt().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), false, localctx.(*ParamContext).GetT().GetResult())

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(308)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(309)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(310)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), false, localctx.(*ParamContext).GetT().GetResult())

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(313)

			var _m = p.Match(ParserParserTK_under)

			localctx.(*ParamContext).ext = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(314)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(315)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(316)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetExt() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetExt().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetExt() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetExt().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), false, localctx.(*ParamContext).GetT().GetResult())

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(319)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ParamContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(320)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(321)

			var _x = p.Typeparam()

			localctx.(*ParamContext).t = _x
		}
		localctx.(*ParamContext).result = *utils.NewParam((func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ParamContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ParamContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), (func() string {
			if localctx.(*ParamContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ParamContext).GetId().GetText()
			}
		}()), false, localctx.(*ParamContext).GetT().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeparamContext is an interface to support dynamic dispatch.
type ITypeparamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTc returns the tc rule contexts.
	GetTc() ITypeCompContext

	// GetTm returns the tm rule contexts.
	GetTm() ITypematrixContext

	// SetTc sets the tc rule contexts.
	SetTc(ITypeCompContext)

	// SetTm sets the tm rule contexts.
	SetTm(ITypematrixContext)

	// GetResult returns the result attribute.
	GetResult() *utils.AttribsType

	// SetResult sets the result attribute.
	SetResult(*utils.AttribsType)

	// Getter signatures
	TypeComp() ITypeCompContext
	Typematrix() ITypematrixContext

	// IsTypeparamContext differentiates from other interfaces.
	IsTypeparamContext()
}

type TypeparamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *utils.AttribsType
	tc     ITypeCompContext
	tm     ITypematrixContext
}

func NewEmptyTypeparamContext() *TypeparamContext {
	var p = new(TypeparamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typeparam
	return p
}

func InitEmptyTypeparamContext(p *TypeparamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typeparam
}

func (*TypeparamContext) IsTypeparamContext() {}

func NewTypeparamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeparamContext {
	var p = new(TypeparamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_typeparam

	return p
}

func (s *TypeparamContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeparamContext) GetTc() ITypeCompContext { return s.tc }

func (s *TypeparamContext) GetTm() ITypematrixContext { return s.tm }

func (s *TypeparamContext) SetTc(v ITypeCompContext) { s.tc = v }

func (s *TypeparamContext) SetTm(v ITypematrixContext) { s.tm = v }

func (s *TypeparamContext) GetResult() *utils.AttribsType { return s.result }

func (s *TypeparamContext) SetResult(v *utils.AttribsType) { s.result = v }

func (s *TypeparamContext) TypeComp() ITypeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCompContext)
}

func (s *TypeparamContext) Typematrix() ITypematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypematrixContext)
}

func (s *TypeparamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeparamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeparamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterTypeparam(s)
	}
}

func (s *TypeparamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitTypeparam(s)
	}
}

func (p *ParserParser) Typeparam() (localctx ITypeparamContext) {
	localctx = NewTypeparamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ParserParserRULE_typeparam)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_Int, ParserParserRW_Float, ParserParserRW_String, ParserParserRW_Bool, ParserParserRW_Character, ParserParserTK_id:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)

			var _x = p.TypeComp()

			localctx.(*TypeparamContext).tc = _x
		}
		t := localctx.(*TypeparamContext).GetTc().GetResult()
		localctx.(*TypeparamContext).result = &t

	case ParserParserTK_lbrk:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(329)

			var _x = p.Typematrix()

			localctx.(*TypeparamContext).tm = _x
		}
		localctx.(*TypeparamContext).result = utils.NewAttribsType(localctx.(*TypeparamContext).GetTm().GetResult().Line, localctx.(*TypeparamContext).GetTm().GetResult().Column, localctx.(*TypeparamContext).GetTm().GetResult(), false)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfstructContext is an interface to support dynamic dispatch.
type IIfstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetR returns the r token.
	GetR() antlr.Token

	// SetR sets the r token.
	SetR(antlr.Token)

	// GetCn returns the cn rule contexts.
	GetCn() IExpContext

	// GetB1 returns the b1 rule contexts.
	GetB1() IEnvContext

	// GetB2 returns the b2 rule contexts.
	GetB2() IIfstructContext

	// GetB3 returns the b3 rule contexts.
	GetB3() IEnvContext

	// SetCn sets the cn rule contexts.
	SetCn(IExpContext)

	// SetB1 sets the b1 rule contexts.
	SetB1(IEnvContext)

	// SetB2 sets the b2 rule contexts.
	SetB2(IIfstructContext)

	// SetB3 sets the b3 rule contexts.
	SetB3(IEnvContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_else() antlr.TerminalNode
	RW_if() antlr.TerminalNode
	Exp() IExpContext
	AllEnv() []IEnvContext
	Env(i int) IEnvContext
	Ifstruct() IIfstructContext

	// IsIfstructContext differentiates from other interfaces.
	IsIfstructContext()
}

type IfstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	r      antlr.Token
	cn     IExpContext
	b1     IEnvContext
	b2     IIfstructContext
	b3     IEnvContext
}

func NewEmptyIfstructContext() *IfstructContext {
	var p = new(IfstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_ifstruct
	return p
}

func InitEmptyIfstructContext(p *IfstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_ifstruct
}

func (*IfstructContext) IsIfstructContext() {}

func NewIfstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfstructContext {
	var p = new(IfstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_ifstruct

	return p
}

func (s *IfstructContext) GetParser() antlr.Parser { return s.parser }

func (s *IfstructContext) GetR() antlr.Token { return s.r }

func (s *IfstructContext) SetR(v antlr.Token) { s.r = v }

func (s *IfstructContext) GetCn() IExpContext { return s.cn }

func (s *IfstructContext) GetB1() IEnvContext { return s.b1 }

func (s *IfstructContext) GetB2() IIfstructContext { return s.b2 }

func (s *IfstructContext) GetB3() IEnvContext { return s.b3 }

func (s *IfstructContext) SetCn(v IExpContext) { s.cn = v }

func (s *IfstructContext) SetB1(v IEnvContext) { s.b1 = v }

func (s *IfstructContext) SetB2(v IIfstructContext) { s.b2 = v }

func (s *IfstructContext) SetB3(v IEnvContext) { s.b3 = v }

func (s *IfstructContext) GetResult() interfaces.Instruction { return s.result }

func (s *IfstructContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *IfstructContext) RW_else() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_else, 0)
}

func (s *IfstructContext) RW_if() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_if, 0)
}

func (s *IfstructContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *IfstructContext) AllEnv() []IEnvContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnvContext); ok {
			len++
		}
	}

	tst := make([]IEnvContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnvContext); ok {
			tst[i] = t.(IEnvContext)
			i++
		}
	}

	return tst
}

func (s *IfstructContext) Env(i int) IEnvContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvContext)
}

func (s *IfstructContext) Ifstruct() IIfstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfstructContext)
}

func (s *IfstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterIfstruct(s)
	}
}

func (s *IfstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitIfstruct(s)
	}
}

func (p *ParserParser) Ifstruct() (localctx IIfstructContext) {
	localctx = NewIfstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ParserParserRULE_ifstruct)
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(334)

			var _m = p.Match(ParserParserRW_if)

			localctx.(*IfstructContext).r = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(335)

			var _x = p.exp(0)

			localctx.(*IfstructContext).cn = _x
		}
		{
			p.SetState(336)

			var _x = p.Env()

			localctx.(*IfstructContext).b1 = _x
		}
		{
			p.SetState(337)
			p.Match(ParserParserRW_else)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(338)

			var _x = p.Ifstruct()

			localctx.(*IfstructContext).b2 = _x
		}
		localctx.(*IfstructContext).result = instructions.NewIf((func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetLine()
			}
		}()), (func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetColumn()
			}
		}()), localctx.(*IfstructContext).GetCn().GetResult(), localctx.(*IfstructContext).GetB1().GetResult(), localctx.(*IfstructContext).GetB2().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(341)

			var _m = p.Match(ParserParserRW_if)

			localctx.(*IfstructContext).r = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)

			var _x = p.exp(0)

			localctx.(*IfstructContext).cn = _x
		}
		{
			p.SetState(343)

			var _x = p.Env()

			localctx.(*IfstructContext).b1 = _x
		}
		{
			p.SetState(344)
			p.Match(ParserParserRW_else)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)

			var _x = p.Env()

			localctx.(*IfstructContext).b3 = _x
		}
		localctx.(*IfstructContext).result = instructions.NewIf((func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetLine()
			}
		}()), (func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetColumn()
			}
		}()), localctx.(*IfstructContext).GetCn().GetResult(), localctx.(*IfstructContext).GetB1().GetResult(), (interface{}(localctx.(*IfstructContext).GetB3().GetResult())).(interfaces.Instruction))

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(348)

			var _m = p.Match(ParserParserRW_if)

			localctx.(*IfstructContext).r = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)

			var _x = p.exp(0)

			localctx.(*IfstructContext).cn = _x
		}
		{
			p.SetState(350)

			var _x = p.Env()

			localctx.(*IfstructContext).b1 = _x
		}
		localctx.(*IfstructContext).result = instructions.NewIf((func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetLine()
			}
		}()), (func() int {
			if localctx.(*IfstructContext).GetR() == nil {
				return 0
			} else {
				return localctx.(*IfstructContext).GetR().GetColumn()
			}
		}()), localctx.(*IfstructContext).GetCn().GetResult(), localctx.(*IfstructContext).GetB1().GetResult(), nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchstructContext is an interface to support dynamic dispatch.
type ISwitchstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s token.
	GetS() antlr.Token

	// SetS sets the s token.
	SetS(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// GetB returns the b rule contexts.
	GetB() IEnvsContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// SetB sets the b rule contexts.
	SetB(IEnvsContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_switch() antlr.TerminalNode
	Exp() IExpContext
	Envs() IEnvsContext

	// IsSwitchstructContext differentiates from other interfaces.
	IsSwitchstructContext()
}

type SwitchstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	s      antlr.Token
	e      IExpContext
	b      IEnvsContext
}

func NewEmptySwitchstructContext() *SwitchstructContext {
	var p = new(SwitchstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_switchstruct
	return p
}

func InitEmptySwitchstructContext(p *SwitchstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_switchstruct
}

func (*SwitchstructContext) IsSwitchstructContext() {}

func NewSwitchstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchstructContext {
	var p = new(SwitchstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_switchstruct

	return p
}

func (s *SwitchstructContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchstructContext) GetS() antlr.Token { return s.s }

func (s *SwitchstructContext) SetS(v antlr.Token) { s.s = v }

func (s *SwitchstructContext) GetE() IExpContext { return s.e }

func (s *SwitchstructContext) GetB() IEnvsContext { return s.b }

func (s *SwitchstructContext) SetE(v IExpContext) { s.e = v }

func (s *SwitchstructContext) SetB(v IEnvsContext) { s.b = v }

func (s *SwitchstructContext) GetResult() interfaces.Instruction { return s.result }

func (s *SwitchstructContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *SwitchstructContext) RW_switch() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_switch, 0)
}

func (s *SwitchstructContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *SwitchstructContext) Envs() IEnvsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvsContext)
}

func (s *SwitchstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterSwitchstruct(s)
	}
}

func (s *SwitchstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitSwitchstruct(s)
	}
}

func (p *ParserParser) Switchstruct() (localctx ISwitchstructContext) {
	localctx = NewSwitchstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ParserParserRULE_switchstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)

		var _m = p.Match(ParserParserRW_switch)

		localctx.(*SwitchstructContext).s = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)

		var _x = p.exp(0)

		localctx.(*SwitchstructContext).e = _x
	}
	{
		p.SetState(357)

		var _x = p.Envs()

		localctx.(*SwitchstructContext).b = _x
	}
	localctx.(*SwitchstructContext).result = instructions.NewSwitch((func() int {
		if localctx.(*SwitchstructContext).GetS() == nil {
			return 0
		} else {
			return localctx.(*SwitchstructContext).GetS().GetLine()
		}
	}()), (func() int {
		if localctx.(*SwitchstructContext).GetS() == nil {
			return 0
		} else {
			return localctx.(*SwitchstructContext).GetS().GetColumn()
		}
	}()), localctx.(*SwitchstructContext).GetE().GetResult(), localctx.(*SwitchstructContext).GetB().GetResult()[0], localctx.(*SwitchstructContext).GetB().GetResult()[1].(interfaces.Instruction))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnvsContext is an interface to support dynamic dispatch.
type IEnvsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCd returns the cd rule contexts.
	GetCd() ICasesdefaultContext

	// SetCd sets the cd rule contexts.
	SetCd(ICasesdefaultContext)

	// GetResult returns the result attribute.
	GetResult() []interface{}

	// SetResult sets the result attribute.
	SetResult([]interface{})

	// Getter signatures
	TK_lbrc() antlr.TerminalNode
	TK_rbrc() antlr.TerminalNode
	Casesdefault() ICasesdefaultContext

	// IsEnvsContext differentiates from other interfaces.
	IsEnvsContext()
}

type EnvsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interface{}
	cd     ICasesdefaultContext
}

func NewEmptyEnvsContext() *EnvsContext {
	var p = new(EnvsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_envs
	return p
}

func InitEmptyEnvsContext(p *EnvsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_envs
}

func (*EnvsContext) IsEnvsContext() {}

func NewEnvsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvsContext {
	var p = new(EnvsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_envs

	return p
}

func (s *EnvsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvsContext) GetCd() ICasesdefaultContext { return s.cd }

func (s *EnvsContext) SetCd(v ICasesdefaultContext) { s.cd = v }

func (s *EnvsContext) GetResult() []interface{} { return s.result }

func (s *EnvsContext) SetResult(v []interface{}) { s.result = v }

func (s *EnvsContext) TK_lbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrc, 0)
}

func (s *EnvsContext) TK_rbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrc, 0)
}

func (s *EnvsContext) Casesdefault() ICasesdefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICasesdefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICasesdefaultContext)
}

func (s *EnvsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterEnvs(s)
	}
}

func (s *EnvsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitEnvs(s)
	}
}

func (p *ParserParser) Envs() (localctx IEnvsContext) {
	localctx = NewEnvsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ParserParserRULE_envs)
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(360)
			p.Match(ParserParserTK_lbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(361)

			var _x = p.Casesdefault()

			localctx.(*EnvsContext).cd = _x
		}
		{
			p.SetState(362)
			p.Match(ParserParserTK_rbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*EnvsContext).result = localctx.(*EnvsContext).GetCd().GetResult()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(365)
			p.Match(ParserParserTK_lbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.Match(ParserParserTK_rbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*EnvsContext).result = []interface{}{nil, nil}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICasesdefaultContext is an interface to support dynamic dispatch.
type ICasesdefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c rule contexts.
	GetC() ICasesContext

	// GetD returns the d rule contexts.
	GetD() IDefaultContext

	// SetC sets the c rule contexts.
	SetC(ICasesContext)

	// SetD sets the d rule contexts.
	SetD(IDefaultContext)

	// GetResult returns the result attribute.
	GetResult() []interface{}

	// SetResult sets the result attribute.
	SetResult([]interface{})

	// Getter signatures
	Cases() ICasesContext
	Default_() IDefaultContext

	// IsCasesdefaultContext differentiates from other interfaces.
	IsCasesdefaultContext()
}

type CasesdefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interface{}
	c      ICasesContext
	d      IDefaultContext
}

func NewEmptyCasesdefaultContext() *CasesdefaultContext {
	var p = new(CasesdefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_casesdefault
	return p
}

func InitEmptyCasesdefaultContext(p *CasesdefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_casesdefault
}

func (*CasesdefaultContext) IsCasesdefaultContext() {}

func NewCasesdefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CasesdefaultContext {
	var p = new(CasesdefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_casesdefault

	return p
}

func (s *CasesdefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *CasesdefaultContext) GetC() ICasesContext { return s.c }

func (s *CasesdefaultContext) GetD() IDefaultContext { return s.d }

func (s *CasesdefaultContext) SetC(v ICasesContext) { s.c = v }

func (s *CasesdefaultContext) SetD(v IDefaultContext) { s.d = v }

func (s *CasesdefaultContext) GetResult() []interface{} { return s.result }

func (s *CasesdefaultContext) SetResult(v []interface{}) { s.result = v }

func (s *CasesdefaultContext) Cases() ICasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICasesContext)
}

func (s *CasesdefaultContext) Default_() IDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultContext)
}

func (s *CasesdefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CasesdefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CasesdefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterCasesdefault(s)
	}
}

func (s *CasesdefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitCasesdefault(s)
	}
}

func (p *ParserParser) Casesdefault() (localctx ICasesdefaultContext) {
	localctx = NewCasesdefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ParserParserRULE_casesdefault)
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(370)

			var _x = p.cases(0)

			localctx.(*CasesdefaultContext).c = _x
		}
		{
			p.SetState(371)

			var _x = p.Default_()

			localctx.(*CasesdefaultContext).d = _x
		}
		localctx.(*CasesdefaultContext).result = []interface{}{localctx.(*CasesdefaultContext).GetC().GetResult(), localctx.(*CasesdefaultContext).GetD().GetResult()}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)

			var _x = p.cases(0)

			localctx.(*CasesdefaultContext).c = _x
		}
		localctx.(*CasesdefaultContext).result = []interface{}{localctx.(*CasesdefaultContext).GetC().GetResult(), nil}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(377)

			var _x = p.Default_()

			localctx.(*CasesdefaultContext).d = _x
		}
		localctx.(*CasesdefaultContext).result = []interface{}{nil, localctx.(*CasesdefaultContext).GetD().GetResult()}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICasesContext is an interface to support dynamic dispatch.
type ICasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() ICasesContext

	// GetC returns the c rule contexts.
	GetC() ICaseContext

	// SetL sets the l rule contexts.
	SetL(ICasesContext)

	// SetC sets the c rule contexts.
	SetC(ICaseContext)

	// GetResult returns the result attribute.
	GetResult() []interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult([]interfaces.Instruction)

	// Getter signatures
	Case_() ICaseContext
	Cases() ICasesContext

	// IsCasesContext differentiates from other interfaces.
	IsCasesContext()
}

type CasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interfaces.Instruction
	l      ICasesContext
	c      ICaseContext
}

func NewEmptyCasesContext() *CasesContext {
	var p = new(CasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_cases
	return p
}

func InitEmptyCasesContext(p *CasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_cases
}

func (*CasesContext) IsCasesContext() {}

func NewCasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CasesContext {
	var p = new(CasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_cases

	return p
}

func (s *CasesContext) GetParser() antlr.Parser { return s.parser }

func (s *CasesContext) GetL() ICasesContext { return s.l }

func (s *CasesContext) GetC() ICaseContext { return s.c }

func (s *CasesContext) SetL(v ICasesContext) { s.l = v }

func (s *CasesContext) SetC(v ICaseContext) { s.c = v }

func (s *CasesContext) GetResult() []interfaces.Instruction { return s.result }

func (s *CasesContext) SetResult(v []interfaces.Instruction) { s.result = v }

func (s *CasesContext) Case_() ICaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseContext)
}

func (s *CasesContext) Cases() ICasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICasesContext)
}

func (s *CasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterCases(s)
	}
}

func (s *CasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitCases(s)
	}
}

func (p *ParserParser) Cases() (localctx ICasesContext) {
	return p.cases(0)
}

func (p *ParserParser) cases(_p int) (localctx ICasesContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewCasesContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ICasesContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, ParserParserRULE_cases, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)

		var _x = p.Case_()

		localctx.(*CasesContext).c = _x
	}
	localctx.(*CasesContext).result = []interfaces.Instruction{localctx.(*CasesContext).GetC().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewCasesContext(p, _parentctx, _parentState)
			localctx.(*CasesContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_cases)
			p.SetState(386)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(387)

				var _x = p.Case_()

				localctx.(*CasesContext).c = _x
			}
			localctx.(*CasesContext).SetResult(localctx.(*CasesContext).GetL().GetResult())
			localctx.(*CasesContext).result = append(localctx.(*CasesContext).result, localctx.(*CasesContext).GetC().GetResult())

		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseContext is an interface to support dynamic dispatch.
type ICaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetC returns the c token.
	GetC() antlr.Token

	// SetC sets the c token.
	SetC(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// GetB returns the b rule contexts.
	GetB() IInstructionsContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// SetB sets the b rule contexts.
	SetB(IInstructionsContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	RW_case() antlr.TerminalNode
	Exp() IExpContext
	Instructions() IInstructionsContext

	// IsCaseContext differentiates from other interfaces.
	IsCaseContext()
}

type CaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	c      antlr.Token
	e      IExpContext
	b      IInstructionsContext
}

func NewEmptyCaseContext() *CaseContext {
	var p = new(CaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_case
	return p
}

func InitEmptyCaseContext(p *CaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_case
}

func (*CaseContext) IsCaseContext() {}

func NewCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseContext {
	var p = new(CaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_case

	return p
}

func (s *CaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseContext) GetC() antlr.Token { return s.c }

func (s *CaseContext) SetC(v antlr.Token) { s.c = v }

func (s *CaseContext) GetE() IExpContext { return s.e }

func (s *CaseContext) GetB() IInstructionsContext { return s.b }

func (s *CaseContext) SetE(v IExpContext) { s.e = v }

func (s *CaseContext) SetB(v IInstructionsContext) { s.b = v }

func (s *CaseContext) GetResult() interfaces.Instruction { return s.result }

func (s *CaseContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *CaseContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *CaseContext) RW_case() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_case, 0)
}

func (s *CaseContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *CaseContext) Instructions() IInstructionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *CaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterCase(s)
	}
}

func (s *CaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitCase(s)
	}
}

func (p *ParserParser) Case_() (localctx ICaseContext) {
	localctx = NewCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ParserParserRULE_case)
	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(395)

			var _m = p.Match(ParserParserRW_case)

			localctx.(*CaseContext).c = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(396)

			var _x = p.exp(0)

			localctx.(*CaseContext).e = _x
		}
		{
			p.SetState(397)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(398)

			var _x = p.instructions(0)

			localctx.(*CaseContext).b = _x
		}
		localctx.(*CaseContext).result = instructions.NewCase((func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetLine()
			}
		}()), (func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetColumn()
			}
		}()), localctx.(*CaseContext).GetE().GetResult(), instructions.NewBlock((func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetLine()
			}
		}()), (func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetColumn()
			}
		}()), localctx.(*CaseContext).GetB().GetResult()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(401)

			var _m = p.Match(ParserParserRW_case)

			localctx.(*CaseContext).c = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)

			var _x = p.exp(0)

			localctx.(*CaseContext).e = _x
		}
		{
			p.SetState(403)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CaseContext).result = instructions.NewCase((func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetLine()
			}
		}()), (func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetColumn()
			}
		}()), localctx.(*CaseContext).GetE().GetResult(), instructions.NewBlock((func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetLine()
			}
		}()), (func() int {
			if localctx.(*CaseContext).GetC() == nil {
				return 0
			} else {
				return localctx.(*CaseContext).GetC().GetColumn()
			}
		}()), []interface{}{}))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultContext is an interface to support dynamic dispatch.
type IDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// GetB returns the b rule contexts.
	GetB() IInstructionsContext

	// SetB sets the b rule contexts.
	SetB(IInstructionsContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	RW_default() antlr.TerminalNode
	Instructions() IInstructionsContext

	// IsDefaultContext differentiates from other interfaces.
	IsDefaultContext()
}

type DefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	d      antlr.Token
	b      IInstructionsContext
}

func NewEmptyDefaultContext() *DefaultContext {
	var p = new(DefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_default
	return p
}

func InitEmptyDefaultContext(p *DefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_default
}

func (*DefaultContext) IsDefaultContext() {}

func NewDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultContext {
	var p = new(DefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_default

	return p
}

func (s *DefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultContext) GetD() antlr.Token { return s.d }

func (s *DefaultContext) SetD(v antlr.Token) { s.d = v }

func (s *DefaultContext) GetB() IInstructionsContext { return s.b }

func (s *DefaultContext) SetB(v IInstructionsContext) { s.b = v }

func (s *DefaultContext) GetResult() interfaces.Instruction { return s.result }

func (s *DefaultContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DefaultContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DefaultContext) RW_default() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_default, 0)
}

func (s *DefaultContext) Instructions() IInstructionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *DefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDefault(s)
	}
}

func (s *DefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDefault(s)
	}
}

func (p *ParserParser) Default_() (localctx IDefaultContext) {
	localctx = NewDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ParserParserRULE_default)
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(408)

			var _m = p.Match(ParserParserRW_default)

			localctx.(*DefaultContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(410)

			var _x = p.instructions(0)

			localctx.(*DefaultContext).b = _x
		}
		localctx.(*DefaultContext).result = instructions.NewBlock((func() int {
			if localctx.(*DefaultContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DefaultContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DefaultContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DefaultContext).GetD().GetColumn()
			}
		}()), localctx.(*DefaultContext).GetB().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(413)

			var _m = p.Match(ParserParserRW_default)

			localctx.(*DefaultContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(414)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DefaultContext).result = instructions.NewBlock((func() int {
			if localctx.(*DefaultContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DefaultContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DefaultContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DefaultContext).GetD().GetColumn()
			}
		}()), []interface{}{})

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopforContext is an interface to support dynamic dispatch.
type ILoopforContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetF returns the f token.
	GetF() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetF sets the f token.
	SetF(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetR returns the r rule contexts.
	GetR() IRangeContext

	// GetB returns the b rule contexts.
	GetB() IEnvContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetR sets the r rule contexts.
	SetR(IRangeContext)

	// SetB sets the b rule contexts.
	SetB(IEnvContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_in() antlr.TerminalNode
	RW_for() antlr.TerminalNode
	Range_() IRangeContext
	Env() IEnvContext
	TK_id() antlr.TerminalNode
	TK_under() antlr.TerminalNode
	Exp() IExpContext

	// IsLoopforContext differentiates from other interfaces.
	IsLoopforContext()
}

type LoopforContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	f      antlr.Token
	id     antlr.Token
	r      IRangeContext
	b      IEnvContext
	e      IExpContext
}

func NewEmptyLoopforContext() *LoopforContext {
	var p = new(LoopforContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_loopfor
	return p
}

func InitEmptyLoopforContext(p *LoopforContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_loopfor
}

func (*LoopforContext) IsLoopforContext() {}

func NewLoopforContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopforContext {
	var p = new(LoopforContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_loopfor

	return p
}

func (s *LoopforContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopforContext) GetF() antlr.Token { return s.f }

func (s *LoopforContext) GetId() antlr.Token { return s.id }

func (s *LoopforContext) SetF(v antlr.Token) { s.f = v }

func (s *LoopforContext) SetId(v antlr.Token) { s.id = v }

func (s *LoopforContext) GetR() IRangeContext { return s.r }

func (s *LoopforContext) GetB() IEnvContext { return s.b }

func (s *LoopforContext) GetE() IExpContext { return s.e }

func (s *LoopforContext) SetR(v IRangeContext) { s.r = v }

func (s *LoopforContext) SetB(v IEnvContext) { s.b = v }

func (s *LoopforContext) SetE(v IExpContext) { s.e = v }

func (s *LoopforContext) GetResult() interfaces.Instruction { return s.result }

func (s *LoopforContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *LoopforContext) RW_in() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_in, 0)
}

func (s *LoopforContext) RW_for() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_for, 0)
}

func (s *LoopforContext) Range_() IRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeContext)
}

func (s *LoopforContext) Env() IEnvContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvContext)
}

func (s *LoopforContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *LoopforContext) TK_under() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_under, 0)
}

func (s *LoopforContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *LoopforContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopforContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopforContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterLoopfor(s)
	}
}

func (s *LoopforContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitLoopfor(s)
	}
}

func (p *ParserParser) Loopfor() (localctx ILoopforContext) {
	localctx = NewLoopforContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ParserParserRULE_loopfor)
	var _la int

	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(418)

			var _m = p.Match(ParserParserRW_for)

			localctx.(*LoopforContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(419)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoopforContext).id = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ParserParserTK_under || _la == ParserParserTK_id) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoopforContext).id = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(420)
			p.Match(ParserParserRW_in)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)

			var _x = p.Range_()

			localctx.(*LoopforContext).r = _x
		}
		{
			p.SetState(422)

			var _x = p.Env()

			localctx.(*LoopforContext).b = _x
		}
		localctx.(*LoopforContext).result = instructions.NewFor((func() int {
			if localctx.(*LoopforContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*LoopforContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*LoopforContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*LoopforContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*LoopforContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*LoopforContext).GetId().GetText()
			}
		}()), nil, localctx.(*LoopforContext).GetR().GetResult()[0], localctx.(*LoopforContext).GetR().GetResult()[1], localctx.(*LoopforContext).GetB().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)

			var _m = p.Match(ParserParserRW_for)

			localctx.(*LoopforContext).f = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(426)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoopforContext).id = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ParserParserTK_under || _la == ParserParserTK_id) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoopforContext).id = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(427)
			p.Match(ParserParserRW_in)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)

			var _x = p.exp(0)

			localctx.(*LoopforContext).e = _x
		}
		{
			p.SetState(429)

			var _x = p.Env()

			localctx.(*LoopforContext).b = _x
		}
		localctx.(*LoopforContext).result = instructions.NewFor((func() int {
			if localctx.(*LoopforContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*LoopforContext).GetF().GetLine()
			}
		}()), (func() int {
			if localctx.(*LoopforContext).GetF() == nil {
				return 0
			} else {
				return localctx.(*LoopforContext).GetF().GetColumn()
			}
		}()), (func() string {
			if localctx.(*LoopforContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*LoopforContext).GetId().GetText()
			}
		}()), localctx.(*LoopforContext).GetE().GetResult(), nil, nil, localctx.(*LoopforContext).GetB().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeContext is an interface to support dynamic dispatch.
type IRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpContext

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpContext)

	// GetResult returns the result attribute.
	GetResult() []interfaces.Expression

	// SetResult sets the result attribute.
	SetResult([]interfaces.Expression)

	// Getter signatures
	AllTK_dot() []antlr.TerminalNode
	TK_dot(i int) antlr.TerminalNode
	AllExp() []IExpContext
	Exp(i int) IExpContext

	// IsRangeContext differentiates from other interfaces.
	IsRangeContext()
}

type RangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interfaces.Expression
	e1     IExpContext
	e2     IExpContext
}

func NewEmptyRangeContext() *RangeContext {
	var p = new(RangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_range
	return p
}

func InitEmptyRangeContext(p *RangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_range
}

func (*RangeContext) IsRangeContext() {}

func NewRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeContext {
	var p = new(RangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_range

	return p
}

func (s *RangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeContext) GetE1() IExpContext { return s.e1 }

func (s *RangeContext) GetE2() IExpContext { return s.e2 }

func (s *RangeContext) SetE1(v IExpContext) { s.e1 = v }

func (s *RangeContext) SetE2(v IExpContext) { s.e2 = v }

func (s *RangeContext) GetResult() []interfaces.Expression { return s.result }

func (s *RangeContext) SetResult(v []interfaces.Expression) { s.result = v }

func (s *RangeContext) AllTK_dot() []antlr.TerminalNode {
	return s.GetTokens(ParserParserTK_dot)
}

func (s *RangeContext) TK_dot(i int) antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, i)
}

func (s *RangeContext) AllExp() []IExpContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpContext); ok {
			len++
		}
	}

	tst := make([]IExpContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpContext); ok {
			tst[i] = t.(IExpContext)
			i++
		}
	}

	return tst
}

func (s *RangeContext) Exp(i int) IExpContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *RangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterRange(s)
	}
}

func (s *RangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitRange(s)
	}
}

func (p *ParserParser) Range_() (localctx IRangeContext) {
	localctx = NewRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ParserParserRULE_range)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)

		var _x = p.exp(0)

		localctx.(*RangeContext).e1 = _x
	}
	{
		p.SetState(435)
		p.Match(ParserParserTK_dot)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(436)
		p.Match(ParserParserTK_dot)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(437)
		p.Match(ParserParserTK_dot)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(438)

		var _x = p.exp(0)

		localctx.(*RangeContext).e2 = _x
	}
	localctx.(*RangeContext).result = []interfaces.Expression{localctx.(*RangeContext).GetE1().GetResult(), localctx.(*RangeContext).GetE2().GetResult()}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopwhileContext is an interface to support dynamic dispatch.
type ILoopwhileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetW returns the w token.
	GetW() antlr.Token

	// SetW sets the w token.
	SetW(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// GetB returns the b rule contexts.
	GetB() IEnvContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// SetB sets the b rule contexts.
	SetB(IEnvContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_while() antlr.TerminalNode
	Exp() IExpContext
	Env() IEnvContext

	// IsLoopwhileContext differentiates from other interfaces.
	IsLoopwhileContext()
}

type LoopwhileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	w      antlr.Token
	e      IExpContext
	b      IEnvContext
}

func NewEmptyLoopwhileContext() *LoopwhileContext {
	var p = new(LoopwhileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_loopwhile
	return p
}

func InitEmptyLoopwhileContext(p *LoopwhileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_loopwhile
}

func (*LoopwhileContext) IsLoopwhileContext() {}

func NewLoopwhileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopwhileContext {
	var p = new(LoopwhileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_loopwhile

	return p
}

func (s *LoopwhileContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopwhileContext) GetW() antlr.Token { return s.w }

func (s *LoopwhileContext) SetW(v antlr.Token) { s.w = v }

func (s *LoopwhileContext) GetE() IExpContext { return s.e }

func (s *LoopwhileContext) GetB() IEnvContext { return s.b }

func (s *LoopwhileContext) SetE(v IExpContext) { s.e = v }

func (s *LoopwhileContext) SetB(v IEnvContext) { s.b = v }

func (s *LoopwhileContext) GetResult() interfaces.Instruction { return s.result }

func (s *LoopwhileContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *LoopwhileContext) RW_while() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_while, 0)
}

func (s *LoopwhileContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *LoopwhileContext) Env() IEnvContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvContext)
}

func (s *LoopwhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopwhileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopwhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterLoopwhile(s)
	}
}

func (s *LoopwhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitLoopwhile(s)
	}
}

func (p *ParserParser) Loopwhile() (localctx ILoopwhileContext) {
	localctx = NewLoopwhileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ParserParserRULE_loopwhile)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)

		var _m = p.Match(ParserParserRW_while)

		localctx.(*LoopwhileContext).w = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(442)

		var _x = p.exp(0)

		localctx.(*LoopwhileContext).e = _x
	}
	{
		p.SetState(443)

		var _x = p.Env()

		localctx.(*LoopwhileContext).b = _x
	}
	localctx.(*LoopwhileContext).result = instructions.NewWhile((func() int {
		if localctx.(*LoopwhileContext).GetW() == nil {
			return 0
		} else {
			return localctx.(*LoopwhileContext).GetW().GetLine()
		}
	}()), (func() int {
		if localctx.(*LoopwhileContext).GetW() == nil {
			return 0
		} else {
			return localctx.(*LoopwhileContext).GetW().GetColumn()
		}
	}()), localctx.(*LoopwhileContext).GetE().GetResult(), localctx.(*LoopwhileContext).GetB().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGuardContext is an interface to support dynamic dispatch.
type IGuardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetG returns the g token.
	GetG() antlr.Token

	// SetG sets the g token.
	SetG(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// GetB returns the b rule contexts.
	GetB() IEnvContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// SetB sets the b rule contexts.
	SetB(IEnvContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_else() antlr.TerminalNode
	RW_guard() antlr.TerminalNode
	Exp() IExpContext
	Env() IEnvContext

	// IsGuardContext differentiates from other interfaces.
	IsGuardContext()
}

type GuardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	g      antlr.Token
	e      IExpContext
	b      IEnvContext
}

func NewEmptyGuardContext() *GuardContext {
	var p = new(GuardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_guard
	return p
}

func InitEmptyGuardContext(p *GuardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_guard
}

func (*GuardContext) IsGuardContext() {}

func NewGuardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GuardContext {
	var p = new(GuardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_guard

	return p
}

func (s *GuardContext) GetParser() antlr.Parser { return s.parser }

func (s *GuardContext) GetG() antlr.Token { return s.g }

func (s *GuardContext) SetG(v antlr.Token) { s.g = v }

func (s *GuardContext) GetE() IExpContext { return s.e }

func (s *GuardContext) GetB() IEnvContext { return s.b }

func (s *GuardContext) SetE(v IExpContext) { s.e = v }

func (s *GuardContext) SetB(v IEnvContext) { s.b = v }

func (s *GuardContext) GetResult() interfaces.Instruction { return s.result }

func (s *GuardContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *GuardContext) RW_else() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_else, 0)
}

func (s *GuardContext) RW_guard() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_guard, 0)
}

func (s *GuardContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *GuardContext) Env() IEnvContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvContext)
}

func (s *GuardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GuardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GuardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterGuard(s)
	}
}

func (s *GuardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitGuard(s)
	}
}

func (p *ParserParser) Guard() (localctx IGuardContext) {
	localctx = NewGuardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ParserParserRULE_guard)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)

		var _m = p.Match(ParserParserRW_guard)

		localctx.(*GuardContext).g = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(447)

		var _x = p.exp(0)

		localctx.(*GuardContext).e = _x
	}
	{
		p.SetState(448)
		p.Match(ParserParserRW_else)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(449)

		var _x = p.Env()

		localctx.(*GuardContext).b = _x
	}
	localctx.(*GuardContext).result = instructions.NewGuard((func() int {
		if localctx.(*GuardContext).GetG() == nil {
			return 0
		} else {
			return localctx.(*GuardContext).GetG().GetLine()
		}
	}()), (func() int {
		if localctx.(*GuardContext).GetG() == nil {
			return 0
		} else {
			return localctx.(*GuardContext).GetG().GetColumn()
		}
	}()), localctx.(*GuardContext).GetE().GetResult(), localctx.(*GuardContext).GetB().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReasignContext is an interface to support dynamic dispatch.
type IReasignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_equ() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Exp() IExpContext

	// IsReasignContext differentiates from other interfaces.
	IsReasignContext()
}

type ReasignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	id     antlr.Token
	e      IExpContext
}

func NewEmptyReasignContext() *ReasignContext {
	var p = new(ReasignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_reasign
	return p
}

func InitEmptyReasignContext(p *ReasignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_reasign
}

func (*ReasignContext) IsReasignContext() {}

func NewReasignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReasignContext {
	var p = new(ReasignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_reasign

	return p
}

func (s *ReasignContext) GetParser() antlr.Parser { return s.parser }

func (s *ReasignContext) GetId() antlr.Token { return s.id }

func (s *ReasignContext) SetId(v antlr.Token) { s.id = v }

func (s *ReasignContext) GetE() IExpContext { return s.e }

func (s *ReasignContext) SetE(v IExpContext) { s.e = v }

func (s *ReasignContext) GetResult() interfaces.Instruction { return s.result }

func (s *ReasignContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *ReasignContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *ReasignContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ReasignContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ReasignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReasignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReasignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterReasign(s)
	}
}

func (s *ReasignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitReasign(s)
	}
}

func (p *ParserParser) Reasign() (localctx IReasignContext) {
	localctx = NewReasignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ParserParserRULE_reasign)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(452)

		var _m = p.Match(ParserParserTK_id)

		localctx.(*ReasignContext).id = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(453)
		p.Match(ParserParserTK_equ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(454)

		var _x = p.exp(0)

		localctx.(*ReasignContext).e = _x
	}
	localctx.(*ReasignContext).result = instructions.NewAsignID((func() int {
		if localctx.(*ReasignContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*ReasignContext).GetId().GetLine()
		}
	}()), (func() int {
		if localctx.(*ReasignContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*ReasignContext).GetId().GetColumn()
		}
	}()), (func() string {
		if localctx.(*ReasignContext).GetId() == nil {
			return ""
		} else {
			return localctx.(*ReasignContext).GetId().GetText()
		}
	}()), localctx.(*ReasignContext).GetE().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddsubContext is an interface to support dynamic dispatch.
type IAddsubContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// GetS returns the s token.
	GetS() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetS sets the s token.
	SetS(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_id() antlr.TerminalNode
	Exp() IExpContext
	TK_add() antlr.TerminalNode
	TK_sub() antlr.TerminalNode

	// IsAddsubContext differentiates from other interfaces.
	IsAddsubContext()
}

type AddsubContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	id     antlr.Token
	s      antlr.Token
	e      IExpContext
}

func NewEmptyAddsubContext() *AddsubContext {
	var p = new(AddsubContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_addsub
	return p
}

func InitEmptyAddsubContext(p *AddsubContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_addsub
}

func (*AddsubContext) IsAddsubContext() {}

func NewAddsubContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddsubContext {
	var p = new(AddsubContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_addsub

	return p
}

func (s *AddsubContext) GetParser() antlr.Parser { return s.parser }

func (s *AddsubContext) GetId() antlr.Token { return s.id }

func (s *AddsubContext) GetS() antlr.Token { return s.s }

func (s *AddsubContext) SetId(v antlr.Token) { s.id = v }

func (s *AddsubContext) SetS(v antlr.Token) { s.s = v }

func (s *AddsubContext) GetE() IExpContext { return s.e }

func (s *AddsubContext) SetE(v IExpContext) { s.e = v }

func (s *AddsubContext) GetResult() interfaces.Instruction { return s.result }

func (s *AddsubContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *AddsubContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *AddsubContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *AddsubContext) TK_add() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_add, 0)
}

func (s *AddsubContext) TK_sub() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_sub, 0)
}

func (s *AddsubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddsubContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddsubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterAddsub(s)
	}
}

func (s *AddsubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitAddsub(s)
	}
}

func (p *ParserParser) Addsub() (localctx IAddsubContext) {
	localctx = NewAddsubContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ParserParserRULE_addsub)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)

		var _m = p.Match(ParserParserTK_id)

		localctx.(*AddsubContext).id = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AddsubContext).s = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == ParserParserTK_add || _la == ParserParserTK_sub) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AddsubContext).s = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(459)

		var _x = p.exp(0)

		localctx.(*AddsubContext).e = _x
	}
	localctx.(*AddsubContext).result = instructions.NewAddSub((func() int {
		if localctx.(*AddsubContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*AddsubContext).GetId().GetLine()
		}
	}()), (func() int {
		if localctx.(*AddsubContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*AddsubContext).GetId().GetColumn()
		}
	}()), (func() string {
		if localctx.(*AddsubContext).GetId() == nil {
			return ""
		} else {
			return localctx.(*AddsubContext).GetId().GetText()
		}
	}()), (func() string {
		if localctx.(*AddsubContext).GetS() == nil {
			return ""
		} else {
			return localctx.(*AddsubContext).GetS().GetText()
		}
	}()), localctx.(*AddsubContext).GetE().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecvectorContext is an interface to support dynamic dispatch.
type IDecvectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypeCompContext

	// GetDf returns the df rule contexts.
	GetDf() IDefvectorContext

	// SetT sets the t rule contexts.
	SetT(ITypeCompContext)

	// SetDf sets the df rule contexts.
	SetDf(IDefvectorContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	TK_lbrk() antlr.TerminalNode
	TK_rbrk() antlr.TerminalNode
	TK_equ() antlr.TerminalNode
	RW_var() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	TypeComp() ITypeCompContext
	Defvector() IDefvectorContext
	RW_let() antlr.TerminalNode

	// IsDecvectorContext differentiates from other interfaces.
	IsDecvectorContext()
}

type DecvectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	d      antlr.Token
	id     antlr.Token
	t      ITypeCompContext
	df     IDefvectorContext
}

func NewEmptyDecvectorContext() *DecvectorContext {
	var p = new(DecvectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decvector
	return p
}

func InitEmptyDecvectorContext(p *DecvectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decvector
}

func (*DecvectorContext) IsDecvectorContext() {}

func NewDecvectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecvectorContext {
	var p = new(DecvectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_decvector

	return p
}

func (s *DecvectorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecvectorContext) GetD() antlr.Token { return s.d }

func (s *DecvectorContext) GetId() antlr.Token { return s.id }

func (s *DecvectorContext) SetD(v antlr.Token) { s.d = v }

func (s *DecvectorContext) SetId(v antlr.Token) { s.id = v }

func (s *DecvectorContext) GetT() ITypeCompContext { return s.t }

func (s *DecvectorContext) GetDf() IDefvectorContext { return s.df }

func (s *DecvectorContext) SetT(v ITypeCompContext) { s.t = v }

func (s *DecvectorContext) SetDf(v IDefvectorContext) { s.df = v }

func (s *DecvectorContext) GetResult() interfaces.Instruction { return s.result }

func (s *DecvectorContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DecvectorContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DecvectorContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *DecvectorContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *DecvectorContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *DecvectorContext) RW_var() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_var, 0)
}

func (s *DecvectorContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DecvectorContext) TypeComp() ITypeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCompContext)
}

func (s *DecvectorContext) Defvector() IDefvectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefvectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefvectorContext)
}

func (s *DecvectorContext) RW_let() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_let, 0)
}

func (s *DecvectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecvectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecvectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDecvector(s)
	}
}

func (s *DecvectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDecvector(s)
	}
}

func (p *ParserParser) Decvector() (localctx IDecvectorContext) {
	localctx = NewDecvectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ParserParserRULE_decvector)
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(462)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecvectorContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(464)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(465)
			p.Match(ParserParserTK_lbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)

			var _x = p.TypeComp()

			localctx.(*DecvectorContext).t = _x
		}
		{
			p.SetState(467)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(468)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)

			var _x = p.Defvector()

			localctx.(*DecvectorContext).df = _x
		}
		attType := localctx.(*DecvectorContext).GetT().GetResult()
		localctx.(*DecvectorContext).SetResult(instructions.NewInitVector((func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvectorContext).GetId().GetText()
			}
		}()), &attType, localctx.(*DecvectorContext).GetDf().GetResult()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(472)

			var _m = p.Match(ParserParserRW_let)

			localctx.(*DecvectorContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			p.Match(ParserParserTK_lbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)

			var _x = p.TypeComp()

			localctx.(*DecvectorContext).t = _x
		}
		{
			p.SetState(477)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(478)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)

			var _x = p.Defvector()

			localctx.(*DecvectorContext).df = _x
		}
		attType := localctx.(*DecvectorContext).GetT().GetResult()
		localctx.(*DecvectorContext).SetResult(instructions.NewInitVector((func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetColumn()
			}
		}()), false, (func() string {
			if localctx.(*DecvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvectorContext).GetId().GetText()
			}
		}()), &attType, localctx.(*DecvectorContext).GetDf().GetResult()))

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(482)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecvectorContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(484)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)

			var _x = p.Defvector()

			localctx.(*DecvectorContext).df = _x
		}
		localctx.(*DecvectorContext).SetResult(instructions.NewInitVector((func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvectorContext).GetId().GetText()
			}
		}()), nil, localctx.(*DecvectorContext).GetDf().GetResult()))

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(488)

			var _m = p.Match(ParserParserRW_let)

			localctx.(*DecvectorContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(489)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)

			var _x = p.Defvector()

			localctx.(*DecvectorContext).df = _x
		}
		localctx.(*DecvectorContext).SetResult(instructions.NewInitVector((func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecvectorContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecvectorContext).GetD().GetColumn()
			}
		}()), false, (func() string {
			if localctx.(*DecvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecvectorContext).GetId().GetText()
			}
		}()), nil, localctx.(*DecvectorContext).GetDf().GetResult()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefvectorContext is an interface to support dynamic dispatch.
type IDefvectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLb returns the lb token.
	GetLb() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetLb sets the lb token.
	SetLb(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetL returns the l rule contexts.
	GetL() IListexpContext

	// GetT returns the t rule contexts.
	GetT() ITypeCompContext

	// SetL sets the l rule contexts.
	SetL(IListexpContext)

	// SetT sets the t rule contexts.
	SetT(ITypeCompContext)

	// GetResult returns the result attribute.
	GetResult() *vector.Vector

	// SetResult sets the result attribute.
	SetResult(*vector.Vector)

	// Getter signatures
	TK_rbrk() antlr.TerminalNode
	TK_lbrk() antlr.TerminalNode
	Listexp() IListexpContext
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	TypeComp() ITypeCompContext
	TK_id() antlr.TerminalNode

	// IsDefvectorContext differentiates from other interfaces.
	IsDefvectorContext()
}

type DefvectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *vector.Vector
	lb     antlr.Token
	l      IListexpContext
	t      ITypeCompContext
	id     antlr.Token
}

func NewEmptyDefvectorContext() *DefvectorContext {
	var p = new(DefvectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defvector
	return p
}

func InitEmptyDefvectorContext(p *DefvectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defvector
}

func (*DefvectorContext) IsDefvectorContext() {}

func NewDefvectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefvectorContext {
	var p = new(DefvectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_defvector

	return p
}

func (s *DefvectorContext) GetParser() antlr.Parser { return s.parser }

func (s *DefvectorContext) GetLb() antlr.Token { return s.lb }

func (s *DefvectorContext) GetId() antlr.Token { return s.id }

func (s *DefvectorContext) SetLb(v antlr.Token) { s.lb = v }

func (s *DefvectorContext) SetId(v antlr.Token) { s.id = v }

func (s *DefvectorContext) GetL() IListexpContext { return s.l }

func (s *DefvectorContext) GetT() ITypeCompContext { return s.t }

func (s *DefvectorContext) SetL(v IListexpContext) { s.l = v }

func (s *DefvectorContext) SetT(v ITypeCompContext) { s.t = v }

func (s *DefvectorContext) GetResult() *vector.Vector { return s.result }

func (s *DefvectorContext) SetResult(v *vector.Vector) { s.result = v }

func (s *DefvectorContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *DefvectorContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *DefvectorContext) Listexp() IListexpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListexpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListexpContext)
}

func (s *DefvectorContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *DefvectorContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *DefvectorContext) TypeComp() ITypeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCompContext)
}

func (s *DefvectorContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DefvectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefvectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefvectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDefvector(s)
	}
}

func (s *DefvectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDefvector(s)
	}
}

func (p *ParserParser) Defvector() (localctx IDefvectorContext) {
	localctx = NewDefvectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ParserParserRULE_defvector)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(496)

			var _m = p.Match(ParserParserTK_lbrk)

			localctx.(*DefvectorContext).lb = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)

			var _x = p.listexp(0)

			localctx.(*DefvectorContext).l = _x
		}
		{
			p.SetState(498)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DefvectorContext).result = vector.NewVector(nil, localctx.(*DefvectorContext).GetL().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(501)

			var _m = p.Match(ParserParserTK_lbrk)

			localctx.(*DefvectorContext).lb = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DefvectorContext).result = vector.NewVector(nil, []interfaces.Expression{})

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(504)

			var _m = p.Match(ParserParserTK_lbrk)

			localctx.(*DefvectorContext).lb = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)

			var _x = p.TypeComp()

			localctx.(*DefvectorContext).t = _x
		}
		{
			p.SetState(506)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(508)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		attType := localctx.(*DefvectorContext).GetT().GetResult()
		localctx.(*DefvectorContext).result = vector.NewVector(&attType, []interfaces.Expression{})

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(511)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DefvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DefvectorContext).result = vector.NewReuseVector((func() string {
			if localctx.(*DefvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DefvectorContext).GetId().GetText()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListexpContext is an interface to support dynamic dispatch.
type IListexpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListexpContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetL sets the l rule contexts.
	SetL(IListexpContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() []interfaces.Expression

	// SetResult sets the result attribute.
	SetResult([]interfaces.Expression)

	// Getter signatures
	Exp() IExpContext
	TK_comma() antlr.TerminalNode
	Listexp() IListexpContext

	// IsListexpContext differentiates from other interfaces.
	IsListexpContext()
}

type ListexpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interfaces.Expression
	l      IListexpContext
	e      IExpContext
}

func NewEmptyListexpContext() *ListexpContext {
	var p = new(ListexpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listexp
	return p
}

func InitEmptyListexpContext(p *ListexpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listexp
}

func (*ListexpContext) IsListexpContext() {}

func NewListexpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListexpContext {
	var p = new(ListexpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_listexp

	return p
}

func (s *ListexpContext) GetParser() antlr.Parser { return s.parser }

func (s *ListexpContext) GetL() IListexpContext { return s.l }

func (s *ListexpContext) GetE() IExpContext { return s.e }

func (s *ListexpContext) SetL(v IListexpContext) { s.l = v }

func (s *ListexpContext) SetE(v IExpContext) { s.e = v }

func (s *ListexpContext) GetResult() []interfaces.Expression { return s.result }

func (s *ListexpContext) SetResult(v []interfaces.Expression) { s.result = v }

func (s *ListexpContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ListexpContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *ListexpContext) Listexp() IListexpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListexpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListexpContext)
}

func (s *ListexpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListexpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListexpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterListexp(s)
	}
}

func (s *ListexpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitListexp(s)
	}
}

func (p *ParserParser) Listexp() (localctx IListexpContext) {
	return p.listexp(0)
}

func (p *ParserParser) listexp(_p int) (localctx IListexpContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListexpContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListexpContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 54
	p.EnterRecursionRule(localctx, 54, ParserParserRULE_listexp, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)

		var _x = p.exp(0)

		localctx.(*ListexpContext).e = _x
	}
	localctx.(*ListexpContext).result = []interfaces.Expression{localctx.(*ListexpContext).GetE().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListexpContext(p, _parentctx, _parentState)
			localctx.(*ListexpContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_listexp)
			p.SetState(519)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(520)
				p.Match(ParserParserTK_comma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(521)

				var _x = p.exp(0)

				localctx.(*ListexpContext).e = _x
			}
			localctx.(*ListexpContext).SetResult(localctx.(*ListexpContext).GetL().GetResult())
			localctx.(*ListexpContext).result = append(localctx.(*ListexpContext).result, localctx.(*ListexpContext).GetE().GetResult())

		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncvectorContext is an interface to support dynamic dispatch.
type IFuncvectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_dot() antlr.TerminalNode
	RW_append() antlr.TerminalNode
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Exp() IExpContext
	RW_removeLast() antlr.TerminalNode
	RW_remove() antlr.TerminalNode
	RW_at() antlr.TerminalNode
	TK_colon() antlr.TerminalNode

	// IsFuncvectorContext differentiates from other interfaces.
	IsFuncvectorContext()
}

type FuncvectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	id     antlr.Token
	e      IExpContext
}

func NewEmptyFuncvectorContext() *FuncvectorContext {
	var p = new(FuncvectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_funcvector
	return p
}

func InitEmptyFuncvectorContext(p *FuncvectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_funcvector
}

func (*FuncvectorContext) IsFuncvectorContext() {}

func NewFuncvectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncvectorContext {
	var p = new(FuncvectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_funcvector

	return p
}

func (s *FuncvectorContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncvectorContext) GetId() antlr.Token { return s.id }

func (s *FuncvectorContext) SetId(v antlr.Token) { s.id = v }

func (s *FuncvectorContext) GetE() IExpContext { return s.e }

func (s *FuncvectorContext) SetE(v IExpContext) { s.e = v }

func (s *FuncvectorContext) GetResult() interfaces.Instruction { return s.result }

func (s *FuncvectorContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *FuncvectorContext) TK_dot() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, 0)
}

func (s *FuncvectorContext) RW_append() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_append, 0)
}

func (s *FuncvectorContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *FuncvectorContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *FuncvectorContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *FuncvectorContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *FuncvectorContext) RW_removeLast() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_removeLast, 0)
}

func (s *FuncvectorContext) RW_remove() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_remove, 0)
}

func (s *FuncvectorContext) RW_at() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_at, 0)
}

func (s *FuncvectorContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *FuncvectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncvectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncvectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterFuncvector(s)
	}
}

func (s *FuncvectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitFuncvector(s)
	}
}

func (p *ParserParser) Funcvector() (localctx IFuncvectorContext) {
	localctx = NewFuncvectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ParserParserRULE_funcvector)
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(529)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*FuncvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(530)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(531)
			p.Match(ParserParserRW_append)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(532)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)

			var _x = p.exp(0)

			localctx.(*FuncvectorContext).e = _x
		}
		{
			p.SetState(534)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*FuncvectorContext).result = instructions.NewAppend((func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*FuncvectorContext).GetId().GetText()
			}
		}()), localctx.(*FuncvectorContext).GetE().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(537)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*FuncvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(538)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(539)
			p.Match(ParserParserRW_removeLast)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*FuncvectorContext).result = instructions.NewRemoveLast((func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*FuncvectorContext).GetId().GetText()
			}
		}()))

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(543)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*FuncvectorContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(545)
			p.Match(ParserParserRW_remove)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(546)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(547)
			p.Match(ParserParserRW_at)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)

			var _x = p.exp(0)

			localctx.(*FuncvectorContext).e = _x
		}
		{
			p.SetState(550)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*FuncvectorContext).result = instructions.NewRemove((func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*FuncvectorContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FuncvectorContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*FuncvectorContext).GetId().GetText()
			}
		}()), localctx.(*FuncvectorContext).GetE().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecmatrixContext is an interface to support dynamic dispatch.
type IDecmatrixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetD returns the d token.
	GetD() antlr.Token

	// GetId returns the id token.
	GetId() antlr.Token

	// SetD sets the d token.
	SetD(antlr.Token)

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypematrixContext

	// GetDf returns the df rule contexts.
	GetDf() IDefmatrixContext

	// SetT sets the t rule contexts.
	SetT(ITypematrixContext)

	// SetDf sets the df rule contexts.
	SetDf(IDefmatrixContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_colon() antlr.TerminalNode
	TK_equ() antlr.TerminalNode
	RW_var() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Typematrix() ITypematrixContext
	Defmatrix() IDefmatrixContext

	// IsDecmatrixContext differentiates from other interfaces.
	IsDecmatrixContext()
}

type DecmatrixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	d      antlr.Token
	id     antlr.Token
	t      ITypematrixContext
	df     IDefmatrixContext
}

func NewEmptyDecmatrixContext() *DecmatrixContext {
	var p = new(DecmatrixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decmatrix
	return p
}

func InitEmptyDecmatrixContext(p *DecmatrixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decmatrix
}

func (*DecmatrixContext) IsDecmatrixContext() {}

func NewDecmatrixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecmatrixContext {
	var p = new(DecmatrixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_decmatrix

	return p
}

func (s *DecmatrixContext) GetParser() antlr.Parser { return s.parser }

func (s *DecmatrixContext) GetD() antlr.Token { return s.d }

func (s *DecmatrixContext) GetId() antlr.Token { return s.id }

func (s *DecmatrixContext) SetD(v antlr.Token) { s.d = v }

func (s *DecmatrixContext) SetId(v antlr.Token) { s.id = v }

func (s *DecmatrixContext) GetT() ITypematrixContext { return s.t }

func (s *DecmatrixContext) GetDf() IDefmatrixContext { return s.df }

func (s *DecmatrixContext) SetT(v ITypematrixContext) { s.t = v }

func (s *DecmatrixContext) SetDf(v IDefmatrixContext) { s.df = v }

func (s *DecmatrixContext) GetResult() interfaces.Instruction { return s.result }

func (s *DecmatrixContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DecmatrixContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DecmatrixContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *DecmatrixContext) RW_var() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_var, 0)
}

func (s *DecmatrixContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DecmatrixContext) Typematrix() ITypematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypematrixContext)
}

func (s *DecmatrixContext) Defmatrix() IDefmatrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefmatrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefmatrixContext)
}

func (s *DecmatrixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecmatrixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecmatrixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDecmatrix(s)
	}
}

func (s *DecmatrixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDecmatrix(s)
	}
}

func (p *ParserParser) Decmatrix() (localctx IDecmatrixContext) {
	localctx = NewDecmatrixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ParserParserRULE_decmatrix)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(555)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecmatrixContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(556)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecmatrixContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)

			var _x = p.Typematrix()

			localctx.(*DecmatrixContext).t = _x
		}
		{
			p.SetState(559)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(560)

			var _x = p.Defmatrix()

			localctx.(*DecmatrixContext).df = _x
		}
		vecType := localctx.(*DecmatrixContext).GetT().GetResult()
		localctx.(*DecmatrixContext).result = instructions.NewInitMatrix((func() int {
			if localctx.(*DecmatrixContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecmatrixContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecmatrixContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecmatrixContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecmatrixContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecmatrixContext).GetId().GetText()
			}
		}()), &vecType, localctx.(*DecmatrixContext).GetDf().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(563)

			var _m = p.Match(ParserParserRW_var)

			localctx.(*DecmatrixContext).d = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*DecmatrixContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(565)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(566)

			var _x = p.Defmatrix()

			localctx.(*DecmatrixContext).df = _x
		}
		localctx.(*DecmatrixContext).result = instructions.NewInitMatrix((func() int {
			if localctx.(*DecmatrixContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecmatrixContext).GetD().GetLine()
			}
		}()), (func() int {
			if localctx.(*DecmatrixContext).GetD() == nil {
				return 0
			} else {
				return localctx.(*DecmatrixContext).GetD().GetColumn()
			}
		}()), true, (func() string {
			if localctx.(*DecmatrixContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*DecmatrixContext).GetId().GetText()
			}
		}()), nil, localctx.(*DecmatrixContext).GetDf().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefmatrixContext is an interface to support dynamic dispatch.
type IDefmatrixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m rule contexts.
	GetM() IMatrixContext

	// GetS returns the s rule contexts.
	GetS() ISimplematrixContext

	// SetM sets the m rule contexts.
	SetM(IMatrixContext)

	// SetS sets the s rule contexts.
	SetS(ISimplematrixContext)

	// GetResult returns the result attribute.
	GetResult() *vector.Vector

	// SetResult sets the result attribute.
	SetResult(*vector.Vector)

	// Getter signatures
	Matrix() IMatrixContext
	Simplematrix() ISimplematrixContext

	// IsDefmatrixContext differentiates from other interfaces.
	IsDefmatrixContext()
}

type DefmatrixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *vector.Vector
	m      IMatrixContext
	s      ISimplematrixContext
}

func NewEmptyDefmatrixContext() *DefmatrixContext {
	var p = new(DefmatrixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defmatrix
	return p
}

func InitEmptyDefmatrixContext(p *DefmatrixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defmatrix
}

func (*DefmatrixContext) IsDefmatrixContext() {}

func NewDefmatrixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefmatrixContext {
	var p = new(DefmatrixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_defmatrix

	return p
}

func (s *DefmatrixContext) GetParser() antlr.Parser { return s.parser }

func (s *DefmatrixContext) GetM() IMatrixContext { return s.m }

func (s *DefmatrixContext) GetS() ISimplematrixContext { return s.s }

func (s *DefmatrixContext) SetM(v IMatrixContext) { s.m = v }

func (s *DefmatrixContext) SetS(v ISimplematrixContext) { s.s = v }

func (s *DefmatrixContext) GetResult() *vector.Vector { return s.result }

func (s *DefmatrixContext) SetResult(v *vector.Vector) { s.result = v }

func (s *DefmatrixContext) Matrix() IMatrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatrixContext)
}

func (s *DefmatrixContext) Simplematrix() ISimplematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplematrixContext)
}

func (s *DefmatrixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefmatrixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefmatrixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDefmatrix(s)
	}
}

func (s *DefmatrixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDefmatrix(s)
	}
}

func (p *ParserParser) Defmatrix() (localctx IDefmatrixContext) {
	localctx = NewDefmatrixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ParserParserRULE_defmatrix)
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(571)

			var _x = p.Matrix()

			localctx.(*DefmatrixContext).m = _x
		}
		localctx.(*DefmatrixContext).result = localctx.(*DefmatrixContext).GetM().GetResult()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(574)

			var _x = p.Simplematrix()

			localctx.(*DefmatrixContext).s = _x
		}
		localctx.(*DefmatrixContext).result = vector.NewMatrixRepeating(localctx.(*DefmatrixContext).GetS().GetResult())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatrixContext is an interface to support dynamic dispatch.
type IMatrixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVs returns the vs rule contexts.
	GetVs() IVectorsContext

	// SetVs sets the vs rule contexts.
	SetVs(IVectorsContext)

	// GetResult returns the result attribute.
	GetResult() *vector.Vector

	// SetResult sets the result attribute.
	SetResult(*vector.Vector)

	// Getter signatures
	TK_lbrk() antlr.TerminalNode
	TK_rbrk() antlr.TerminalNode
	Vectors() IVectorsContext

	// IsMatrixContext differentiates from other interfaces.
	IsMatrixContext()
}

type MatrixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *vector.Vector
	vs     IVectorsContext
}

func NewEmptyMatrixContext() *MatrixContext {
	var p = new(MatrixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_matrix
	return p
}

func InitEmptyMatrixContext(p *MatrixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_matrix
}

func (*MatrixContext) IsMatrixContext() {}

func NewMatrixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatrixContext {
	var p = new(MatrixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_matrix

	return p
}

func (s *MatrixContext) GetParser() antlr.Parser { return s.parser }

func (s *MatrixContext) GetVs() IVectorsContext { return s.vs }

func (s *MatrixContext) SetVs(v IVectorsContext) { s.vs = v }

func (s *MatrixContext) GetResult() *vector.Vector { return s.result }

func (s *MatrixContext) SetResult(v *vector.Vector) { s.result = v }

func (s *MatrixContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *MatrixContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *MatrixContext) Vectors() IVectorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorsContext)
}

func (s *MatrixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatrixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatrixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterMatrix(s)
	}
}

func (s *MatrixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitMatrix(s)
	}
}

func (p *ParserParser) Matrix() (localctx IMatrixContext) {
	localctx = NewMatrixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ParserParserRULE_matrix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(ParserParserTK_lbrk)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(580)

		var _x = p.vectors(0)

		localctx.(*MatrixContext).vs = _x
	}
	{
		p.SetState(581)
		p.Match(ParserParserTK_rbrk)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*MatrixContext).result = vector.NewMatrix(nil, localctx.(*MatrixContext).GetVs().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorsContext is an interface to support dynamic dispatch.
type IVectorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVs returns the vs rule contexts.
	GetVs() IVectorsContext

	// GetV returns the v rule contexts.
	GetV() IVectorContext

	// SetVs sets the vs rule contexts.
	SetVs(IVectorsContext)

	// SetV sets the v rule contexts.
	SetV(IVectorContext)

	// GetResult returns the result attribute.
	GetResult() []*vector.Vector

	// SetResult sets the result attribute.
	SetResult([]*vector.Vector)

	// Getter signatures
	Vector() IVectorContext
	TK_comma() antlr.TerminalNode
	Vectors() IVectorsContext

	// IsVectorsContext differentiates from other interfaces.
	IsVectorsContext()
}

type VectorsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []*vector.Vector
	vs     IVectorsContext
	v      IVectorContext
}

func NewEmptyVectorsContext() *VectorsContext {
	var p = new(VectorsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_vectors
	return p
}

func InitEmptyVectorsContext(p *VectorsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_vectors
}

func (*VectorsContext) IsVectorsContext() {}

func NewVectorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorsContext {
	var p = new(VectorsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_vectors

	return p
}

func (s *VectorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorsContext) GetVs() IVectorsContext { return s.vs }

func (s *VectorsContext) GetV() IVectorContext { return s.v }

func (s *VectorsContext) SetVs(v IVectorsContext) { s.vs = v }

func (s *VectorsContext) SetV(v IVectorContext) { s.v = v }

func (s *VectorsContext) GetResult() []*vector.Vector { return s.result }

func (s *VectorsContext) SetResult(v []*vector.Vector) { s.result = v }

func (s *VectorsContext) Vector() IVectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorContext)
}

func (s *VectorsContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *VectorsContext) Vectors() IVectorsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorsContext)
}

func (s *VectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterVectors(s)
	}
}

func (s *VectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitVectors(s)
	}
}

func (p *ParserParser) Vectors() (localctx IVectorsContext) {
	return p.vectors(0)
}

func (p *ParserParser) vectors(_p int) (localctx IVectorsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewVectorsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IVectorsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, ParserParserRULE_vectors, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(585)

		var _x = p.Vector()

		localctx.(*VectorsContext).v = _x
	}
	localctx.(*VectorsContext).result = []*vector.Vector{localctx.(*VectorsContext).GetV().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewVectorsContext(p, _parentctx, _parentState)
			localctx.(*VectorsContext).vs = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_vectors)
			p.SetState(588)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(589)
				p.Match(ParserParserTK_comma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(590)

				var _x = p.Vector()

				localctx.(*VectorsContext).v = _x
			}
			localctx.(*VectorsContext).SetResult(localctx.(*VectorsContext).GetVs().GetResult())
			localctx.(*VectorsContext).result = append(localctx.(*VectorsContext).result, localctx.(*VectorsContext).GetV().GetResult())

		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorContext is an interface to support dynamic dispatch.
type IVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IListexpContext

	// GetM returns the m rule contexts.
	GetM() IMatrixContext

	// SetL sets the l rule contexts.
	SetL(IListexpContext)

	// SetM sets the m rule contexts.
	SetM(IMatrixContext)

	// GetResult returns the result attribute.
	GetResult() *vector.Vector

	// SetResult sets the result attribute.
	SetResult(*vector.Vector)

	// Getter signatures
	TK_lbrk() antlr.TerminalNode
	TK_rbrk() antlr.TerminalNode
	Listexp() IListexpContext
	Matrix() IMatrixContext

	// IsVectorContext differentiates from other interfaces.
	IsVectorContext()
}

type VectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *vector.Vector
	l      IListexpContext
	m      IMatrixContext
}

func NewEmptyVectorContext() *VectorContext {
	var p = new(VectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_vector
	return p
}

func InitEmptyVectorContext(p *VectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_vector
}

func (*VectorContext) IsVectorContext() {}

func NewVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorContext {
	var p = new(VectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_vector

	return p
}

func (s *VectorContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorContext) GetL() IListexpContext { return s.l }

func (s *VectorContext) GetM() IMatrixContext { return s.m }

func (s *VectorContext) SetL(v IListexpContext) { s.l = v }

func (s *VectorContext) SetM(v IMatrixContext) { s.m = v }

func (s *VectorContext) GetResult() *vector.Vector { return s.result }

func (s *VectorContext) SetResult(v *vector.Vector) { s.result = v }

func (s *VectorContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *VectorContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *VectorContext) Listexp() IListexpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListexpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListexpContext)
}

func (s *VectorContext) Matrix() IMatrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatrixContext)
}

func (s *VectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterVector(s)
	}
}

func (s *VectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitVector(s)
	}
}

func (p *ParserParser) Vector() (localctx IVectorContext) {
	localctx = NewVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ParserParserRULE_vector)
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(598)
			p.Match(ParserParserTK_lbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)

			var _x = p.listexp(0)

			localctx.(*VectorContext).l = _x
		}
		{
			p.SetState(600)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorContext).result = vector.NewVector(nil, localctx.(*VectorContext).GetL().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(603)

			var _x = p.Matrix()

			localctx.(*VectorContext).m = _x
		}
		localctx.(*VectorContext).result = localctx.(*VectorContext).GetM().GetResult()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplematrixContext is an interface to support dynamic dispatch.
type ISimplematrixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() ITypematrixContext

	// GetR returns the r rule contexts.
	GetR() ISimplematrixContext

	// GetC returns the c rule contexts.
	GetC() IExpContext

	// GetV returns the v rule contexts.
	GetV() IExpContext

	// SetT sets the t rule contexts.
	SetT(ITypematrixContext)

	// SetR sets the r rule contexts.
	SetR(ISimplematrixContext)

	// SetC sets the c rule contexts.
	SetC(IExpContext)

	// SetV sets the v rule contexts.
	SetV(IExpContext)

	// GetResult returns the result attribute.
	GetResult() *vector.Repeating

	// SetResult sets the result attribute.
	SetResult(*vector.Repeating)

	// Getter signatures
	TK_lpar() antlr.TerminalNode
	RW_repeating() antlr.TerminalNode
	AllTK_colon() []antlr.TerminalNode
	TK_colon(i int) antlr.TerminalNode
	TK_comma() antlr.TerminalNode
	RW_count() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	Typematrix() ITypematrixContext
	Simplematrix() ISimplematrixContext
	AllExp() []IExpContext
	Exp(i int) IExpContext

	// IsSimplematrixContext differentiates from other interfaces.
	IsSimplematrixContext()
}

type SimplematrixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result *vector.Repeating
	t      ITypematrixContext
	r      ISimplematrixContext
	c      IExpContext
	v      IExpContext
}

func NewEmptySimplematrixContext() *SimplematrixContext {
	var p = new(SimplematrixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_simplematrix
	return p
}

func InitEmptySimplematrixContext(p *SimplematrixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_simplematrix
}

func (*SimplematrixContext) IsSimplematrixContext() {}

func NewSimplematrixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplematrixContext {
	var p = new(SimplematrixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_simplematrix

	return p
}

func (s *SimplematrixContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplematrixContext) GetT() ITypematrixContext { return s.t }

func (s *SimplematrixContext) GetR() ISimplematrixContext { return s.r }

func (s *SimplematrixContext) GetC() IExpContext { return s.c }

func (s *SimplematrixContext) GetV() IExpContext { return s.v }

func (s *SimplematrixContext) SetT(v ITypematrixContext) { s.t = v }

func (s *SimplematrixContext) SetR(v ISimplematrixContext) { s.r = v }

func (s *SimplematrixContext) SetC(v IExpContext) { s.c = v }

func (s *SimplematrixContext) SetV(v IExpContext) { s.v = v }

func (s *SimplematrixContext) GetResult() *vector.Repeating { return s.result }

func (s *SimplematrixContext) SetResult(v *vector.Repeating) { s.result = v }

func (s *SimplematrixContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *SimplematrixContext) RW_repeating() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_repeating, 0)
}

func (s *SimplematrixContext) AllTK_colon() []antlr.TerminalNode {
	return s.GetTokens(ParserParserTK_colon)
}

func (s *SimplematrixContext) TK_colon(i int) antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, i)
}

func (s *SimplematrixContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *SimplematrixContext) RW_count() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_count, 0)
}

func (s *SimplematrixContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *SimplematrixContext) Typematrix() ITypematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypematrixContext)
}

func (s *SimplematrixContext) Simplematrix() ISimplematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplematrixContext)
}

func (s *SimplematrixContext) AllExp() []IExpContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpContext); ok {
			len++
		}
	}

	tst := make([]IExpContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpContext); ok {
			tst[i] = t.(IExpContext)
			i++
		}
	}

	return tst
}

func (s *SimplematrixContext) Exp(i int) IExpContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *SimplematrixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplematrixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplematrixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterSimplematrix(s)
	}
}

func (s *SimplematrixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitSimplematrix(s)
	}
}

func (p *ParserParser) Simplematrix() (localctx ISimplematrixContext) {
	localctx = NewSimplematrixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ParserParserRULE_simplematrix)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)

			var _x = p.Typematrix()

			localctx.(*SimplematrixContext).t = _x
		}
		{
			p.SetState(609)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(610)
			p.Match(ParserParserRW_repeating)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(611)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)

			var _x = p.Simplematrix()

			localctx.(*SimplematrixContext).r = _x
		}
		{
			p.SetState(613)
			p.Match(ParserParserTK_comma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(614)
			p.Match(ParserParserRW_count)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)

			var _x = p.exp(0)

			localctx.(*SimplematrixContext).c = _x
		}
		{
			p.SetState(617)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SimplematrixContext).result = vector.NewRepeating(localctx.(*SimplematrixContext).GetT().GetResult().Length, localctx.(*SimplematrixContext).GetR().GetResult().Dims+1, localctx.(*SimplematrixContext).GetT().GetResult().Type.Value.(utils.Type), nil, localctx.(*SimplematrixContext).GetC().GetResult(), localctx.(*SimplematrixContext).GetR().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)

			var _x = p.Typematrix()

			localctx.(*SimplematrixContext).t = _x
		}
		{
			p.SetState(621)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(622)
			p.Match(ParserParserRW_repeating)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)

			var _x = p.exp(0)

			localctx.(*SimplematrixContext).v = _x
		}
		{
			p.SetState(625)
			p.Match(ParserParserTK_comma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.Match(ParserParserRW_count)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)

			var _x = p.exp(0)

			localctx.(*SimplematrixContext).c = _x
		}
		{
			p.SetState(629)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SimplematrixContext).result = vector.NewRepeating(localctx.(*SimplematrixContext).GetT().GetResult().Length, 1, localctx.(*SimplematrixContext).GetT().GetResult().Type.Value.(utils.Type), localctx.(*SimplematrixContext).GetV().GetResult(), localctx.(*SimplematrixContext).GetC().GetResult(), nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypematrixContext is an interface to support dynamic dispatch.
type ITypematrixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetB returns the b token.
	GetB() antlr.Token

	// SetB sets the b token.
	SetB(antlr.Token)

	// GetTm returns the tm rule contexts.
	GetTm() ITypematrixContext

	// GetT returns the t rule contexts.
	GetT() ITypeContext

	// SetTm sets the tm rule contexts.
	SetTm(ITypematrixContext)

	// SetT sets the t rule contexts.
	SetT(ITypeContext)

	// GetResult returns the result attribute.
	GetResult() utils.VectorType

	// SetResult sets the result attribute.
	SetResult(utils.VectorType)

	// Getter signatures
	TK_lbrk() antlr.TerminalNode
	TK_rbrk() antlr.TerminalNode
	Typematrix() ITypematrixContext
	Type_() ITypeContext

	// IsTypematrixContext differentiates from other interfaces.
	IsTypematrixContext()
}

type TypematrixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result utils.VectorType
	tm     ITypematrixContext
	b      antlr.Token
	t      ITypeContext
}

func NewEmptyTypematrixContext() *TypematrixContext {
	var p = new(TypematrixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typematrix
	return p
}

func InitEmptyTypematrixContext(p *TypematrixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typematrix
}

func (*TypematrixContext) IsTypematrixContext() {}

func NewTypematrixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypematrixContext {
	var p = new(TypematrixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_typematrix

	return p
}

func (s *TypematrixContext) GetParser() antlr.Parser { return s.parser }

func (s *TypematrixContext) GetB() antlr.Token { return s.b }

func (s *TypematrixContext) SetB(v antlr.Token) { s.b = v }

func (s *TypematrixContext) GetTm() ITypematrixContext { return s.tm }

func (s *TypematrixContext) GetT() ITypeContext { return s.t }

func (s *TypematrixContext) SetTm(v ITypematrixContext) { s.tm = v }

func (s *TypematrixContext) SetT(v ITypeContext) { s.t = v }

func (s *TypematrixContext) GetResult() utils.VectorType { return s.result }

func (s *TypematrixContext) SetResult(v utils.VectorType) { s.result = v }

func (s *TypematrixContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *TypematrixContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *TypematrixContext) Typematrix() ITypematrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypematrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypematrixContext)
}

func (s *TypematrixContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypematrixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypematrixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypematrixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterTypematrix(s)
	}
}

func (s *TypematrixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitTypematrix(s)
	}
}

func (p *ParserParser) Typematrix() (localctx ITypematrixContext) {
	localctx = NewTypematrixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ParserParserRULE_typematrix)
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.Match(ParserParserTK_lbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(635)

			var _x = p.Typematrix()

			localctx.(*TypematrixContext).tm = _x
		}
		{
			p.SetState(636)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypematrixContext).SetResult(localctx.(*TypematrixContext).GetTm().GetResult())
		localctx.(*TypematrixContext).result.Length += 1

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)

			var _m = p.Match(ParserParserTK_lbrk)

			localctx.(*TypematrixContext).b = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)

			var _x = p.Type_()

			localctx.(*TypematrixContext).t = _x
		}
		{
			p.SetState(641)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypematrixContext).result = utils.VectorType{Line: (func() int {
			if localctx.(*TypematrixContext).GetB() == nil {
				return 0
			} else {
				return localctx.(*TypematrixContext).GetB().GetLine()
			}
		}()), Column: (func() int {
			if localctx.(*TypematrixContext).GetB() == nil {
				return 0
			} else {
				return localctx.(*TypematrixContext).GetB().GetColumn()
			}
		}()), Length: 1, Type: localctx.(*TypematrixContext).GetT().GetResult()}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReasignvectorContext is an interface to support dynamic dispatch.
type IReasignvectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// GetIndex returns the index rule contexts.
	GetIndex() IDimsContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetIndex sets the index rule contexts.
	SetIndex(IDimsContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_equ() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Dims() IDimsContext
	Exp() IExpContext

	// IsReasignvectorContext differentiates from other interfaces.
	IsReasignvectorContext()
}

type ReasignvectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	id     antlr.Token
	index  IDimsContext
	e      IExpContext
}

func NewEmptyReasignvectorContext() *ReasignvectorContext {
	var p = new(ReasignvectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_reasignvector
	return p
}

func InitEmptyReasignvectorContext(p *ReasignvectorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_reasignvector
}

func (*ReasignvectorContext) IsReasignvectorContext() {}

func NewReasignvectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReasignvectorContext {
	var p = new(ReasignvectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_reasignvector

	return p
}

func (s *ReasignvectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ReasignvectorContext) GetId() antlr.Token { return s.id }

func (s *ReasignvectorContext) SetId(v antlr.Token) { s.id = v }

func (s *ReasignvectorContext) GetIndex() IDimsContext { return s.index }

func (s *ReasignvectorContext) GetE() IExpContext { return s.e }

func (s *ReasignvectorContext) SetIndex(v IDimsContext) { s.index = v }

func (s *ReasignvectorContext) SetE(v IExpContext) { s.e = v }

func (s *ReasignvectorContext) GetResult() interfaces.Instruction { return s.result }

func (s *ReasignvectorContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *ReasignvectorContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *ReasignvectorContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ReasignvectorContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ReasignvectorContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ReasignvectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReasignvectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReasignvectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterReasignvector(s)
	}
}

func (s *ReasignvectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitReasignvector(s)
	}
}

func (p *ParserParser) Reasignvector() (localctx IReasignvectorContext) {
	localctx = NewReasignvectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ParserParserRULE_reasignvector)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)

		var _m = p.Match(ParserParserTK_id)

		localctx.(*ReasignvectorContext).id = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(647)

		var _x = p.dims(0)

		localctx.(*ReasignvectorContext).index = _x
	}
	{
		p.SetState(648)
		p.Match(ParserParserTK_equ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(649)

		var _x = p.exp(0)

		localctx.(*ReasignvectorContext).e = _x
	}
	localctx.(*ReasignvectorContext).result = instructions.NewAsignPosArray((func() int {
		if localctx.(*ReasignvectorContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*ReasignvectorContext).GetId().GetLine()
		}
	}()), (func() int {
		if localctx.(*ReasignvectorContext).GetId() == nil {
			return 0
		} else {
			return localctx.(*ReasignvectorContext).GetId().GetColumn()
		}
	}()), (func() string {
		if localctx.(*ReasignvectorContext).GetId() == nil {
			return ""
		} else {
			return localctx.(*ReasignvectorContext).GetId().GetText()
		}
	}()), localctx.(*ReasignvectorContext).GetIndex().GetResult(), localctx.(*ReasignvectorContext).GetE().GetResult())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDimsContext is an interface to support dynamic dispatch.
type IDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IDimsContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetL sets the l rule contexts.
	SetL(IDimsContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() []interfaces.Expression

	// SetResult sets the result attribute.
	SetResult([]interfaces.Expression)

	// Getter signatures
	TK_lbrk() antlr.TerminalNode
	TK_rbrk() antlr.TerminalNode
	Exp() IExpContext
	Dims() IDimsContext

	// IsDimsContext differentiates from other interfaces.
	IsDimsContext()
}

type DimsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interfaces.Expression
	l      IDimsContext
	e      IExpContext
}

func NewEmptyDimsContext() *DimsContext {
	var p = new(DimsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_dims
	return p
}

func InitEmptyDimsContext(p *DimsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_dims
}

func (*DimsContext) IsDimsContext() {}

func NewDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsContext {
	var p = new(DimsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_dims

	return p
}

func (s *DimsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsContext) GetL() IDimsContext { return s.l }

func (s *DimsContext) GetE() IExpContext { return s.e }

func (s *DimsContext) SetL(v IDimsContext) { s.l = v }

func (s *DimsContext) SetE(v IExpContext) { s.e = v }

func (s *DimsContext) GetResult() []interfaces.Expression { return s.result }

func (s *DimsContext) SetResult(v []interfaces.Expression) { s.result = v }

func (s *DimsContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *DimsContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *DimsContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *DimsContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *DimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDims(s)
	}
}

func (s *DimsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDims(s)
	}
}

func (p *ParserParser) Dims() (localctx IDimsContext) {
	return p.dims(0)
}

func (p *ParserParser) dims(_p int) (localctx IDimsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewDimsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDimsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, ParserParserRULE_dims, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Match(ParserParserTK_lbrk)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(654)

		var _x = p.exp(0)

		localctx.(*DimsContext).e = _x
	}
	{
		p.SetState(655)
		p.Match(ParserParserTK_rbrk)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*DimsContext).result = []interfaces.Expression{localctx.(*DimsContext).GetE().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDimsContext(p, _parentctx, _parentState)
			localctx.(*DimsContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_dims)
			p.SetState(658)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(659)
				p.Match(ParserParserTK_lbrk)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(660)

				var _x = p.exp(0)

				localctx.(*DimsContext).e = _x
			}
			{
				p.SetState(661)
				p.Match(ParserParserTK_rbrk)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DimsContext).SetResult(localctx.(*DimsContext).GetL().GetResult())
			localctx.(*DimsContext).result = append(localctx.(*DimsContext).result, localctx.(*DimsContext).GetE().GetResult())

		}
		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefstructContext is an interface to support dynamic dispatch.
type IDefstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	RW_struct() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	TK_lbrc() antlr.TerminalNode
	Listattribs() IListattribsContext
	TK_rbrc() antlr.TerminalNode

	// IsDefstructContext differentiates from other interfaces.
	IsDefstructContext()
}

type DefstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
}

func NewEmptyDefstructContext() *DefstructContext {
	var p = new(DefstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defstruct
	return p
}

func InitEmptyDefstructContext(p *DefstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_defstruct
}

func (*DefstructContext) IsDefstructContext() {}

func NewDefstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefstructContext {
	var p = new(DefstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_defstruct

	return p
}

func (s *DefstructContext) GetParser() antlr.Parser { return s.parser }

func (s *DefstructContext) GetResult() interfaces.Instruction { return s.result }

func (s *DefstructContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DefstructContext) RW_struct() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_struct, 0)
}

func (s *DefstructContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *DefstructContext) TK_lbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrc, 0)
}

func (s *DefstructContext) Listattribs() IListattribsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListattribsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListattribsContext)
}

func (s *DefstructContext) TK_rbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrc, 0)
}

func (s *DefstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDefstruct(s)
	}
}

func (s *DefstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDefstruct(s)
	}
}

func (p *ParserParser) Defstruct() (localctx IDefstructContext) {
	localctx = NewDefstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ParserParserRULE_defstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(ParserParserRW_struct)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(670)
		p.Match(ParserParserTK_id)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(671)
		p.Match(ParserParserTK_lbrc)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(672)
		p.listattribs(0)
	}
	{
		p.SetState(673)
		p.Match(ParserParserTK_rbrc)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListattribsContext is an interface to support dynamic dispatch.
type IListattribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attrib() IAttribContext
	TK_semicolon() antlr.TerminalNode
	Listattribs() IListattribsContext

	// IsListattribsContext differentiates from other interfaces.
	IsListattribsContext()
}

type ListattribsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListattribsContext() *ListattribsContext {
	var p = new(ListattribsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listattribs
	return p
}

func InitEmptyListattribsContext(p *ListattribsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listattribs
}

func (*ListattribsContext) IsListattribsContext() {}

func NewListattribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListattribsContext {
	var p = new(ListattribsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_listattribs

	return p
}

func (s *ListattribsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListattribsContext) Attrib() IAttribContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribContext)
}

func (s *ListattribsContext) TK_semicolon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_semicolon, 0)
}

func (s *ListattribsContext) Listattribs() IListattribsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListattribsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListattribsContext)
}

func (s *ListattribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListattribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListattribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterListattribs(s)
	}
}

func (s *ListattribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitListattribs(s)
	}
}

func (p *ParserParser) Listattribs() (localctx IListattribsContext) {
	return p.listattribs(0)
}

func (p *ParserParser) listattribs(_p int) (localctx IListattribsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListattribsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListattribsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, ParserParserRULE_listattribs, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Attrib()
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(677)
			p.Match(ParserParserTK_semicolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListattribsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_listattribs)
			p.SetState(680)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(682)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ParserParserTK_semicolon {
				{
					p.SetState(681)
					p.Match(ParserParserTK_semicolon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(684)
				p.Attrib()
			}

		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribContext is an interface to support dynamic dispatch.
type IAttribContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TK_id() antlr.TerminalNode
	RW_let() antlr.TerminalNode
	RW_var() antlr.TerminalNode
	TK_colon() antlr.TerminalNode
	TypeComp() ITypeCompContext
	TK_equ() antlr.TerminalNode
	Exp() IExpContext
	Declfunc() IDeclfuncContext
	RW_mutating() antlr.TerminalNode

	// IsAttribContext differentiates from other interfaces.
	IsAttribContext()
}

type AttribContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribContext() *AttribContext {
	var p = new(AttribContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_attrib
	return p
}

func InitEmptyAttribContext(p *AttribContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_attrib
}

func (*AttribContext) IsAttribContext() {}

func NewAttribContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribContext {
	var p = new(AttribContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_attrib

	return p
}

func (s *AttribContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *AttribContext) RW_let() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_let, 0)
}

func (s *AttribContext) RW_var() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_var, 0)
}

func (s *AttribContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *AttribContext) TypeComp() ITypeCompContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCompContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCompContext)
}

func (s *AttribContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *AttribContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *AttribContext) Declfunc() IDeclfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclfuncContext)
}

func (s *AttribContext) RW_mutating() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_mutating, 0)
}

func (s *AttribContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttribContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterAttrib(s)
	}
}

func (s *AttribContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitAttrib(s)
	}
}

func (p *ParserParser) Attrib() (localctx IAttribContext) {
	localctx = NewAttribContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ParserParserRULE_attrib)
	var _la int

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_var, ParserParserRW_let:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ParserParserRW_var || _la == ParserParserRW_let) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(691)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(692)
				p.Match(ParserParserTK_colon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(693)
				p.TypeComp()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(696)
				p.Match(ParserParserTK_equ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(697)
				p.exp(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case ParserParserRW_func, ParserParserRW_mutating:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_mutating {
			{
				p.SetState(700)
				p.Match(ParserParserRW_mutating)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(703)
			p.Declfunc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecstructContext is an interface to support dynamic dispatch.
type IDecstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	AllTK_id() []antlr.TerminalNode
	TK_id(i int) antlr.TerminalNode
	TK_equ() antlr.TerminalNode
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	RW_let() antlr.TerminalNode
	RW_var() antlr.TerminalNode
	TK_colon() antlr.TerminalNode
	Listdupla() IListduplaContext

	// IsDecstructContext differentiates from other interfaces.
	IsDecstructContext()
}

type DecstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
}

func NewEmptyDecstructContext() *DecstructContext {
	var p = new(DecstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decstruct
	return p
}

func InitEmptyDecstructContext(p *DecstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_decstruct
}

func (*DecstructContext) IsDecstructContext() {}

func NewDecstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecstructContext {
	var p = new(DecstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_decstruct

	return p
}

func (s *DecstructContext) GetParser() antlr.Parser { return s.parser }

func (s *DecstructContext) GetResult() interfaces.Instruction { return s.result }

func (s *DecstructContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *DecstructContext) AllTK_id() []antlr.TerminalNode {
	return s.GetTokens(ParserParserTK_id)
}

func (s *DecstructContext) TK_id(i int) antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, i)
}

func (s *DecstructContext) TK_equ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equ, 0)
}

func (s *DecstructContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *DecstructContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *DecstructContext) RW_let() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_let, 0)
}

func (s *DecstructContext) RW_var() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_var, 0)
}

func (s *DecstructContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *DecstructContext) Listdupla() IListduplaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListduplaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListduplaContext)
}

func (s *DecstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterDecstruct(s)
	}
}

func (s *DecstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitDecstruct(s)
	}
}

func (p *ParserParser) Decstruct() (localctx IDecstructContext) {
	localctx = NewDecstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ParserParserRULE_decstruct)
	var _la int

	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(706)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ParserParserRW_var || _la == ParserParserRW_let) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(707)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserTK_colon {
			{
				p.SetState(708)
				p.Match(ParserParserTK_colon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(709)
				p.Match(ParserParserTK_id)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(712)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(713)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserTK_id {
			{
				p.SetState(715)
				p.Listdupla()
			}

		}
		{
			p.SetState(718)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(719)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ParserParserRW_var || _la == ParserParserRW_let) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(720)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserTK_colon {
			{
				p.SetState(721)
				p.Match(ParserParserTK_colon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(722)
				p.Match(ParserParserTK_id)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(725)
			p.Match(ParserParserTK_equ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListduplaContext is an interface to support dynamic dispatch.
type IListduplaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TK_id() antlr.TerminalNode
	TK_colon() antlr.TerminalNode
	Exp() IExpContext
	TK_comma() antlr.TerminalNode
	Listdupla() IListduplaContext

	// IsListduplaContext differentiates from other interfaces.
	IsListduplaContext()
}

type ListduplaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListduplaContext() *ListduplaContext {
	var p = new(ListduplaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listdupla
	return p
}

func InitEmptyListduplaContext(p *ListduplaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_listdupla
}

func (*ListduplaContext) IsListduplaContext() {}

func NewListduplaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListduplaContext {
	var p = new(ListduplaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_listdupla

	return p
}

func (s *ListduplaContext) GetParser() antlr.Parser { return s.parser }

func (s *ListduplaContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ListduplaContext) TK_colon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_colon, 0)
}

func (s *ListduplaContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ListduplaContext) TK_comma() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_comma, 0)
}

func (s *ListduplaContext) Listdupla() IListduplaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListduplaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListduplaContext)
}

func (s *ListduplaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListduplaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListduplaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterListdupla(s)
	}
}

func (s *ListduplaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitListdupla(s)
	}
}

func (p *ParserParser) Listdupla() (localctx IListduplaContext) {
	localctx = NewListduplaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ParserParserRULE_listdupla)
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.exp(0)
		}
		{
			p.SetState(734)
			p.Match(ParserParserTK_comma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.Listdupla()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(737)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Match(ParserParserTK_colon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(739)
			p.exp(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseattribsContext is an interface to support dynamic dispatch.
type IUseattribsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResult returns the result attribute.
	GetResult() interfaces.Expression

	// SetResult sets the result attribute.
	SetResult(interfaces.Expression)

	// Getter signatures
	Obj() IObjContext
	Useattribs1() IUseattribs1Context
	TK_dot() antlr.TerminalNode
	Callfunc() ICallfuncContext

	// IsUseattribsContext differentiates from other interfaces.
	IsUseattribsContext()
}

type UseattribsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Expression
}

func NewEmptyUseattribsContext() *UseattribsContext {
	var p = new(UseattribsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_useattribs
	return p
}

func InitEmptyUseattribsContext(p *UseattribsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_useattribs
}

func (*UseattribsContext) IsUseattribsContext() {}

func NewUseattribsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseattribsContext {
	var p = new(UseattribsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_useattribs

	return p
}

func (s *UseattribsContext) GetParser() antlr.Parser { return s.parser }

func (s *UseattribsContext) GetResult() interfaces.Expression { return s.result }

func (s *UseattribsContext) SetResult(v interfaces.Expression) { s.result = v }

func (s *UseattribsContext) Obj() IObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjContext)
}

func (s *UseattribsContext) Useattribs1() IUseattribs1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseattribs1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseattribs1Context)
}

func (s *UseattribsContext) TK_dot() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, 0)
}

func (s *UseattribsContext) Callfunc() ICallfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallfuncContext)
}

func (s *UseattribsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseattribsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseattribsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterUseattribs(s)
	}
}

func (s *UseattribsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitUseattribs(s)
	}
}

func (p *ParserParser) Useattribs() (localctx IUseattribsContext) {
	localctx = NewUseattribsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ParserParserRULE_useattribs)
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			p.Obj()
		}
		{
			p.SetState(743)
			p.Useattribs1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Obj()
		}
		{
			p.SetState(746)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.Callfunc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjContext is an interface to support dynamic dispatch.
type IObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TK_id() antlr.TerminalNode
	TK_lbrk() antlr.TerminalNode
	Exp() IExpContext
	TK_rbrk() antlr.TerminalNode

	// IsObjContext differentiates from other interfaces.
	IsObjContext()
}

type ObjContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjContext() *ObjContext {
	var p = new(ObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_obj
	return p
}

func InitEmptyObjContext(p *ObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_obj
}

func (*ObjContext) IsObjContext() {}

func NewObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjContext {
	var p = new(ObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_obj

	return p
}

func (s *ObjContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ObjContext) TK_lbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrk, 0)
}

func (s *ObjContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ObjContext) TK_rbrk() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrk, 0)
}

func (s *ObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterObj(s)
	}
}

func (s *ObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitObj(s)
	}
}

func (p *ParserParser) Obj() (localctx IObjContext) {
	localctx = NewObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ParserParserRULE_obj)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)
			p.Match(ParserParserTK_lbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)
			p.exp(0)
		}
		{
			p.SetState(754)
			p.Match(ParserParserTK_rbrk)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseattribs1Context is an interface to support dynamic dispatch.
type IUseattribs1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TK_dot() antlr.TerminalNode
	TK_id() antlr.TerminalNode
	Useattribs1() IUseattribs1Context

	// IsUseattribs1Context differentiates from other interfaces.
	IsUseattribs1Context()
}

type Useattribs1Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseattribs1Context() *Useattribs1Context {
	var p = new(Useattribs1Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_useattribs1
	return p
}

func InitEmptyUseattribs1Context(p *Useattribs1Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_useattribs1
}

func (*Useattribs1Context) IsUseattribs1Context() {}

func NewUseattribs1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Useattribs1Context {
	var p = new(Useattribs1Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_useattribs1

	return p
}

func (s *Useattribs1Context) GetParser() antlr.Parser { return s.parser }

func (s *Useattribs1Context) TK_dot() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, 0)
}

func (s *Useattribs1Context) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *Useattribs1Context) Useattribs1() IUseattribs1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseattribs1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseattribs1Context)
}

func (s *Useattribs1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Useattribs1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Useattribs1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterUseattribs1(s)
	}
}

func (s *Useattribs1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitUseattribs1(s)
	}
}

func (p *ParserParser) Useattribs1() (localctx IUseattribs1Context) {
	localctx = NewUseattribs1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ParserParserRULE_useattribs1)
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(759)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(760)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.Useattribs1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(762)
			p.Match(ParserParserTK_dot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(ParserParserTK_id)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintContext is an interface to support dynamic dispatch.
type IPrintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetP returns the p token.
	GetP() antlr.Token

	// SetP sets the p token.
	SetP(antlr.Token)

	// GetExps returns the exps rule contexts.
	GetExps() IListexpContext

	// SetExps sets the exps rule contexts.
	SetExps(IListexpContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	RW_print() antlr.TerminalNode
	Listexp() IListexpContext

	// IsPrintContext differentiates from other interfaces.
	IsPrintContext()
}

type PrintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	p      antlr.Token
	exps   IListexpContext
}

func NewEmptyPrintContext() *PrintContext {
	var p = new(PrintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_print
	return p
}

func InitEmptyPrintContext(p *PrintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_print
}

func (*PrintContext) IsPrintContext() {}

func NewPrintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintContext {
	var p = new(PrintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_print

	return p
}

func (s *PrintContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintContext) GetP() antlr.Token { return s.p }

func (s *PrintContext) SetP(v antlr.Token) { s.p = v }

func (s *PrintContext) GetExps() IListexpContext { return s.exps }

func (s *PrintContext) SetExps(v IListexpContext) { s.exps = v }

func (s *PrintContext) GetResult() interfaces.Instruction { return s.result }

func (s *PrintContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *PrintContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *PrintContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *PrintContext) RW_print() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_print, 0)
}

func (s *PrintContext) Listexp() IListexpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListexpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListexpContext)
}

func (s *PrintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterPrint(s)
	}
}

func (s *PrintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitPrint(s)
	}
}

func (p *ParserParser) Print_() (localctx IPrintContext) {
	localctx = NewPrintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ParserParserRULE_print)
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)

			var _m = p.Match(ParserParserRW_print)

			localctx.(*PrintContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(767)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(768)

			var _x = p.listexp(0)

			localctx.(*PrintContext).exps = _x
		}
		{
			p.SetState(769)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*PrintContext).result = instructions.NewPrint((func() int {
			if localctx.(*PrintContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*PrintContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*PrintContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*PrintContext).GetP().GetColumn()
			}
		}()), localctx.(*PrintContext).GetExps().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)

			var _m = p.Match(ParserParserRW_print)

			localctx.(*PrintContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(774)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*PrintContext).result = instructions.NewPrint((func() int {
			if localctx.(*PrintContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*PrintContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*PrintContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*PrintContext).GetP().GetColumn()
			}
		}()), nil)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnvContext is an interface to support dynamic dispatch.
type IEnvContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l token.
	GetL() antlr.Token

	// SetL sets the l token.
	SetL(antlr.Token)

	// GetIns returns the ins rule contexts.
	GetIns() IInstructionsContext

	// SetIns sets the ins rule contexts.
	SetIns(IInstructionsContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Instruction

	// SetResult sets the result attribute.
	SetResult(interfaces.Instruction)

	// Getter signatures
	TK_rbrc() antlr.TerminalNode
	TK_lbrc() antlr.TerminalNode
	Instructions() IInstructionsContext

	// IsEnvContext differentiates from other interfaces.
	IsEnvContext()
}

type EnvContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Instruction
	l      antlr.Token
	ins    IInstructionsContext
}

func NewEmptyEnvContext() *EnvContext {
	var p = new(EnvContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_env
	return p
}

func InitEmptyEnvContext(p *EnvContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_env
}

func (*EnvContext) IsEnvContext() {}

func NewEnvContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvContext {
	var p = new(EnvContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_env

	return p
}

func (s *EnvContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvContext) GetL() antlr.Token { return s.l }

func (s *EnvContext) SetL(v antlr.Token) { s.l = v }

func (s *EnvContext) GetIns() IInstructionsContext { return s.ins }

func (s *EnvContext) SetIns(v IInstructionsContext) { s.ins = v }

func (s *EnvContext) GetResult() interfaces.Instruction { return s.result }

func (s *EnvContext) SetResult(v interfaces.Instruction) { s.result = v }

func (s *EnvContext) TK_rbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rbrc, 0)
}

func (s *EnvContext) TK_lbrc() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lbrc, 0)
}

func (s *EnvContext) Instructions() IInstructionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *EnvContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterEnv(s)
	}
}

func (s *EnvContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitEnv(s)
	}
}

func (p *ParserParser) Env() (localctx IEnvContext) {
	localctx = NewEnvContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ParserParserRULE_env)
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(778)

			var _m = p.Match(ParserParserTK_lbrc)

			localctx.(*EnvContext).l = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(779)

			var _x = p.instructions(0)

			localctx.(*EnvContext).ins = _x
		}
		{
			p.SetState(780)
			p.Match(ParserParserTK_rbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*EnvContext).result = instructions.NewBlock((func() int {
			if localctx.(*EnvContext).GetL() == nil {
				return 0
			} else {
				return localctx.(*EnvContext).GetL().GetLine()
			}
		}()), (func() int {
			if localctx.(*EnvContext).GetL() == nil {
				return 0
			} else {
				return localctx.(*EnvContext).GetL().GetColumn()
			}
		}()), localctx.(*EnvContext).GetIns().GetResult())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)

			var _m = p.Match(ParserParserTK_lbrc)

			localctx.(*EnvContext).l = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)
			p.Match(ParserParserTK_rbrc)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*EnvContext).result = instructions.NewBlock((func() int {
			if localctx.(*EnvContext).GetL() == nil {
				return 0
			} else {
				return localctx.(*EnvContext).GetL().GetLine()
			}
		}()), (func() int {
			if localctx.(*EnvContext).GetL() == nil {
				return 0
			} else {
				return localctx.(*EnvContext).GetL().GetColumn()
			}
		}()), []interface{}{})

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionsContext is an interface to support dynamic dispatch.
type IInstructionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetL returns the l rule contexts.
	GetL() IInstructionsContext

	// GetI returns the i rule contexts.
	GetI() IInstructionContext

	// SetL sets the l rule contexts.
	SetL(IInstructionsContext)

	// SetI sets the i rule contexts.
	SetI(IInstructionContext)

	// GetResult returns the result attribute.
	GetResult() []interface{}

	// SetResult sets the result attribute.
	SetResult([]interface{})

	// Getter signatures
	Instruction() IInstructionContext
	Instructions() IInstructionsContext

	// IsInstructionsContext differentiates from other interfaces.
	IsInstructionsContext()
}

type InstructionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result []interface{}
	l      IInstructionsContext
	i      IInstructionContext
}

func NewEmptyInstructionsContext() *InstructionsContext {
	var p = new(InstructionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instructions
	return p
}

func InitEmptyInstructionsContext(p *InstructionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instructions
}

func (*InstructionsContext) IsInstructionsContext() {}

func NewInstructionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionsContext {
	var p = new(InstructionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_instructions

	return p
}

func (s *InstructionsContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionsContext) GetL() IInstructionsContext { return s.l }

func (s *InstructionsContext) GetI() IInstructionContext { return s.i }

func (s *InstructionsContext) SetL(v IInstructionsContext) { s.l = v }

func (s *InstructionsContext) SetI(v IInstructionContext) { s.i = v }

func (s *InstructionsContext) GetResult() []interface{} { return s.result }

func (s *InstructionsContext) SetResult(v []interface{}) { s.result = v }

func (s *InstructionsContext) Instruction() IInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *InstructionsContext) Instructions() IInstructionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionsContext)
}

func (s *InstructionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterInstructions(s)
	}
}

func (s *InstructionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitInstructions(s)
	}
}

func (p *ParserParser) Instructions() (localctx IInstructionsContext) {
	return p.instructions(0)
}

func (p *ParserParser) instructions(_p int) (localctx IInstructionsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewInstructionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInstructionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 96
	p.EnterRecursionRule(localctx, 96, ParserParserRULE_instructions, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)

		var _x = p.Instruction()

		localctx.(*InstructionsContext).i = _x
	}
	localctx.(*InstructionsContext).result = []interface{}{localctx.(*InstructionsContext).GetI().GetResult()}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInstructionsContext(p, _parentctx, _parentState)
			localctx.(*InstructionsContext).l = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_instructions)
			p.SetState(792)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(793)

				var _x = p.Instruction()

				localctx.(*InstructionsContext).i = _x
			}
			localctx.(*InstructionsContext).SetResult(localctx.(*InstructionsContext).GetL().GetResult())
			localctx.(*InstructionsContext).result = append(localctx.(*InstructionsContext).result, localctx.(*InstructionsContext).GetI().GetResult())

		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionContext is an interface to support dynamic dispatch.
type IInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInst18 returns the inst18 token.
	GetInst18() antlr.Token

	// GetInst19 returns the inst19 token.
	GetInst19() antlr.Token

	// GetInst20 returns the inst20 token.
	GetInst20() antlr.Token

	// GetInst21 returns the inst21 token.
	GetInst21() antlr.Token

	// SetInst18 sets the inst18 token.
	SetInst18(antlr.Token)

	// SetInst19 sets the inst19 token.
	SetInst19(antlr.Token)

	// SetInst20 sets the inst20 token.
	SetInst20(antlr.Token)

	// SetInst21 sets the inst21 token.
	SetInst21(antlr.Token)

	// GetInst1 returns the inst1 rule contexts.
	GetInst1() IDecvarContext

	// GetInst2 returns the inst2 rule contexts.
	GetInst2() IDeccstContext

	// GetInst3 returns the inst3 rule contexts.
	GetInst3() IIfstructContext

	// GetInst4 returns the inst4 rule contexts.
	GetInst4() ISwitchstructContext

	// GetInst5 returns the inst5 rule contexts.
	GetInst5() ILoopforContext

	// GetInst6 returns the inst6 rule contexts.
	GetInst6() ILoopwhileContext

	// GetInst7 returns the inst7 rule contexts.
	GetInst7() IGuardContext

	// GetInst8 returns the inst8 rule contexts.
	GetInst8() IReasignContext

	// GetInst9 returns the inst9 rule contexts.
	GetInst9() IAddsubContext

	// GetInst10 returns the inst10 rule contexts.
	GetInst10() IDecvectorContext

	// GetInst11 returns the inst11 rule contexts.
	GetInst11() IFuncvectorContext

	// GetInst12 returns the inst12 rule contexts.
	GetInst12() IReasignvectorContext

	// GetInst13 returns the inst13 rule contexts.
	GetInst13() IDecmatrixContext

	// GetInst14 returns the inst14 rule contexts.
	GetInst14() IDecstructContext

	// GetInst15 returns the inst15 rule contexts.
	GetInst15() IUseattribsContext

	// GetInst16 returns the inst16 rule contexts.
	GetInst16() ICallfuncContext

	// GetInst17 returns the inst17 rule contexts.
	GetInst17() IPrintContext

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// SetInst1 sets the inst1 rule contexts.
	SetInst1(IDecvarContext)

	// SetInst2 sets the inst2 rule contexts.
	SetInst2(IDeccstContext)

	// SetInst3 sets the inst3 rule contexts.
	SetInst3(IIfstructContext)

	// SetInst4 sets the inst4 rule contexts.
	SetInst4(ISwitchstructContext)

	// SetInst5 sets the inst5 rule contexts.
	SetInst5(ILoopforContext)

	// SetInst6 sets the inst6 rule contexts.
	SetInst6(ILoopwhileContext)

	// SetInst7 sets the inst7 rule contexts.
	SetInst7(IGuardContext)

	// SetInst8 sets the inst8 rule contexts.
	SetInst8(IReasignContext)

	// SetInst9 sets the inst9 rule contexts.
	SetInst9(IAddsubContext)

	// SetInst10 sets the inst10 rule contexts.
	SetInst10(IDecvectorContext)

	// SetInst11 sets the inst11 rule contexts.
	SetInst11(IFuncvectorContext)

	// SetInst12 sets the inst12 rule contexts.
	SetInst12(IReasignvectorContext)

	// SetInst13 sets the inst13 rule contexts.
	SetInst13(IDecmatrixContext)

	// SetInst14 sets the inst14 rule contexts.
	SetInst14(IDecstructContext)

	// SetInst15 sets the inst15 rule contexts.
	SetInst15(IUseattribsContext)

	// SetInst16 sets the inst16 rule contexts.
	SetInst16(ICallfuncContext)

	// SetInst17 sets the inst17 rule contexts.
	SetInst17(IPrintContext)

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// GetResult returns the result attribute.
	GetResult() interface{}

	// SetResult sets the result attribute.
	SetResult(interface{})

	// Getter signatures
	Decvar() IDecvarContext
	TK_semicolon() antlr.TerminalNode
	Deccst() IDeccstContext
	Ifstruct() IIfstructContext
	Switchstruct() ISwitchstructContext
	Loopfor() ILoopforContext
	Loopwhile() ILoopwhileContext
	Guard() IGuardContext
	Reasign() IReasignContext
	RW_self() antlr.TerminalNode
	TK_dot() antlr.TerminalNode
	Addsub() IAddsubContext
	Decvector() IDecvectorContext
	Funcvector() IFuncvectorContext
	Reasignvector() IReasignvectorContext
	Decmatrix() IDecmatrixContext
	Decstruct() IDecstructContext
	Useattribs() IUseattribsContext
	Callfunc() ICallfuncContext
	Print_() IPrintContext
	RW_return() antlr.TerminalNode
	Exp() IExpContext
	RW_continue() antlr.TerminalNode
	RW_break() antlr.TerminalNode

	// IsInstructionContext differentiates from other interfaces.
	IsInstructionContext()
}

type InstructionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interface{}
	inst1  IDecvarContext
	inst2  IDeccstContext
	inst3  IIfstructContext
	inst4  ISwitchstructContext
	inst5  ILoopforContext
	inst6  ILoopwhileContext
	inst7  IGuardContext
	inst8  IReasignContext
	inst9  IAddsubContext
	inst10 IDecvectorContext
	inst11 IFuncvectorContext
	inst12 IReasignvectorContext
	inst13 IDecmatrixContext
	inst14 IDecstructContext
	inst15 IUseattribsContext
	inst16 ICallfuncContext
	inst17 IPrintContext
	inst18 antlr.Token
	e      IExpContext
	inst19 antlr.Token
	inst20 antlr.Token
	inst21 antlr.Token
}

func NewEmptyInstructionContext() *InstructionContext {
	var p = new(InstructionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instruction
	return p
}

func InitEmptyInstructionContext(p *InstructionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_instruction
}

func (*InstructionContext) IsInstructionContext() {}

func NewInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionContext {
	var p = new(InstructionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_instruction

	return p
}

func (s *InstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionContext) GetInst18() antlr.Token { return s.inst18 }

func (s *InstructionContext) GetInst19() antlr.Token { return s.inst19 }

func (s *InstructionContext) GetInst20() antlr.Token { return s.inst20 }

func (s *InstructionContext) GetInst21() antlr.Token { return s.inst21 }

func (s *InstructionContext) SetInst18(v antlr.Token) { s.inst18 = v }

func (s *InstructionContext) SetInst19(v antlr.Token) { s.inst19 = v }

func (s *InstructionContext) SetInst20(v antlr.Token) { s.inst20 = v }

func (s *InstructionContext) SetInst21(v antlr.Token) { s.inst21 = v }

func (s *InstructionContext) GetInst1() IDecvarContext { return s.inst1 }

func (s *InstructionContext) GetInst2() IDeccstContext { return s.inst2 }

func (s *InstructionContext) GetInst3() IIfstructContext { return s.inst3 }

func (s *InstructionContext) GetInst4() ISwitchstructContext { return s.inst4 }

func (s *InstructionContext) GetInst5() ILoopforContext { return s.inst5 }

func (s *InstructionContext) GetInst6() ILoopwhileContext { return s.inst6 }

func (s *InstructionContext) GetInst7() IGuardContext { return s.inst7 }

func (s *InstructionContext) GetInst8() IReasignContext { return s.inst8 }

func (s *InstructionContext) GetInst9() IAddsubContext { return s.inst9 }

func (s *InstructionContext) GetInst10() IDecvectorContext { return s.inst10 }

func (s *InstructionContext) GetInst11() IFuncvectorContext { return s.inst11 }

func (s *InstructionContext) GetInst12() IReasignvectorContext { return s.inst12 }

func (s *InstructionContext) GetInst13() IDecmatrixContext { return s.inst13 }

func (s *InstructionContext) GetInst14() IDecstructContext { return s.inst14 }

func (s *InstructionContext) GetInst15() IUseattribsContext { return s.inst15 }

func (s *InstructionContext) GetInst16() ICallfuncContext { return s.inst16 }

func (s *InstructionContext) GetInst17() IPrintContext { return s.inst17 }

func (s *InstructionContext) GetE() IExpContext { return s.e }

func (s *InstructionContext) SetInst1(v IDecvarContext) { s.inst1 = v }

func (s *InstructionContext) SetInst2(v IDeccstContext) { s.inst2 = v }

func (s *InstructionContext) SetInst3(v IIfstructContext) { s.inst3 = v }

func (s *InstructionContext) SetInst4(v ISwitchstructContext) { s.inst4 = v }

func (s *InstructionContext) SetInst5(v ILoopforContext) { s.inst5 = v }

func (s *InstructionContext) SetInst6(v ILoopwhileContext) { s.inst6 = v }

func (s *InstructionContext) SetInst7(v IGuardContext) { s.inst7 = v }

func (s *InstructionContext) SetInst8(v IReasignContext) { s.inst8 = v }

func (s *InstructionContext) SetInst9(v IAddsubContext) { s.inst9 = v }

func (s *InstructionContext) SetInst10(v IDecvectorContext) { s.inst10 = v }

func (s *InstructionContext) SetInst11(v IFuncvectorContext) { s.inst11 = v }

func (s *InstructionContext) SetInst12(v IReasignvectorContext) { s.inst12 = v }

func (s *InstructionContext) SetInst13(v IDecmatrixContext) { s.inst13 = v }

func (s *InstructionContext) SetInst14(v IDecstructContext) { s.inst14 = v }

func (s *InstructionContext) SetInst15(v IUseattribsContext) { s.inst15 = v }

func (s *InstructionContext) SetInst16(v ICallfuncContext) { s.inst16 = v }

func (s *InstructionContext) SetInst17(v IPrintContext) { s.inst17 = v }

func (s *InstructionContext) SetE(v IExpContext) { s.e = v }

func (s *InstructionContext) GetResult() interface{} { return s.result }

func (s *InstructionContext) SetResult(v interface{}) { s.result = v }

func (s *InstructionContext) Decvar() IDecvarContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecvarContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecvarContext)
}

func (s *InstructionContext) TK_semicolon() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_semicolon, 0)
}

func (s *InstructionContext) Deccst() IDeccstContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeccstContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeccstContext)
}

func (s *InstructionContext) Ifstruct() IIfstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfstructContext)
}

func (s *InstructionContext) Switchstruct() ISwitchstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchstructContext)
}

func (s *InstructionContext) Loopfor() ILoopforContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopforContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopforContext)
}

func (s *InstructionContext) Loopwhile() ILoopwhileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopwhileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopwhileContext)
}

func (s *InstructionContext) Guard() IGuardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardContext)
}

func (s *InstructionContext) Reasign() IReasignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReasignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReasignContext)
}

func (s *InstructionContext) RW_self() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_self, 0)
}

func (s *InstructionContext) TK_dot() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, 0)
}

func (s *InstructionContext) Addsub() IAddsubContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddsubContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddsubContext)
}

func (s *InstructionContext) Decvector() IDecvectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecvectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecvectorContext)
}

func (s *InstructionContext) Funcvector() IFuncvectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncvectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncvectorContext)
}

func (s *InstructionContext) Reasignvector() IReasignvectorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReasignvectorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReasignvectorContext)
}

func (s *InstructionContext) Decmatrix() IDecmatrixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecmatrixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecmatrixContext)
}

func (s *InstructionContext) Decstruct() IDecstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecstructContext)
}

func (s *InstructionContext) Useattribs() IUseattribsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseattribsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseattribsContext)
}

func (s *InstructionContext) Callfunc() ICallfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallfuncContext)
}

func (s *InstructionContext) Print_() IPrintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintContext)
}

func (s *InstructionContext) RW_return() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_return, 0)
}

func (s *InstructionContext) Exp() IExpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *InstructionContext) RW_continue() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_continue, 0)
}

func (s *InstructionContext) RW_break() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_break, 0)
}

func (s *InstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterInstruction(s)
	}
}

func (s *InstructionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitInstruction(s)
	}
}

func (p *ParserParser) Instruction() (localctx IInstructionContext) {
	localctx = NewInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ParserParserRULE_instruction)
	var _la int

	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(801)

			var _x = p.Decvar()

			localctx.(*InstructionContext).inst1 = _x
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(802)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst1().GetResult()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(807)

			var _x = p.Deccst()

			localctx.(*InstructionContext).inst2 = _x
		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(808)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst2().GetResult()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(813)

			var _x = p.Ifstruct()

			localctx.(*InstructionContext).inst3 = _x
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst3().GetResult()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(816)

			var _x = p.Switchstruct()

			localctx.(*InstructionContext).inst4 = _x
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst4().GetResult()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(819)

			var _x = p.Loopfor()

			localctx.(*InstructionContext).inst5 = _x
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst5().GetResult()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(822)

			var _x = p.Loopwhile()

			localctx.(*InstructionContext).inst6 = _x
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst6().GetResult()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(825)

			var _x = p.Guard()

			localctx.(*InstructionContext).inst7 = _x
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst7().GetResult()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(828)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(829)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(832)

			var _x = p.Reasign()

			localctx.(*InstructionContext).inst8 = _x
		}
		p.SetState(834)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(833)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst8().GetResult()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(838)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(839)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(842)

			var _x = p.Addsub()

			localctx.(*InstructionContext).inst9 = _x
		}
		p.SetState(844)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(843)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst9().GetResult()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(848)

			var _x = p.Decvector()

			localctx.(*InstructionContext).inst10 = _x
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(849)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst10().GetResult()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(854)

			var _x = p.Funcvector()

			localctx.(*InstructionContext).inst11 = _x
		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(855)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst11().GetResult()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(860)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(861)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(864)

			var _x = p.Reasignvector()

			localctx.(*InstructionContext).inst12 = _x
		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(865)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst12().GetResult()

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(870)

			var _x = p.Decmatrix()

			localctx.(*InstructionContext).inst13 = _x
		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(871)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst13().GetResult()

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(876)

			var _x = p.Decstruct()

			localctx.(*InstructionContext).inst14 = _x
		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(877)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst14().GetResult()

	case 15:
		p.EnterOuterAlt(localctx, 15)
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(882)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(883)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(886)

			var _x = p.Useattribs()

			localctx.(*InstructionContext).inst15 = _x
		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(887)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst15().GetResult()

	case 16:
		p.EnterOuterAlt(localctx, 16)
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(892)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(893)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(896)

			var _x = p.Callfunc()

			localctx.(*InstructionContext).inst16 = _x
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(897)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst16().GetResult()

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(902)

			var _x = p.Print_()

			localctx.(*InstructionContext).inst17 = _x
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(903)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = localctx.(*InstructionContext).GetInst17().GetResult()

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(908)

			var _m = p.Match(ParserParserRW_return)

			localctx.(*InstructionContext).inst18 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(909)

			var _x = p.exp(0)

			localctx.(*InstructionContext).e = _x
		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(910)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = expressions.NewReturn((func() int {
			if localctx.(*InstructionContext).GetInst18() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst18().GetLine()
			}
		}()), (func() int {
			if localctx.(*InstructionContext).GetInst18() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst18().GetLine()
			}
		}()), localctx.(*InstructionContext).GetE().GetResult())

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(915)

			var _m = p.Match(ParserParserRW_return)

			localctx.(*InstructionContext).inst19 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(916)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = expressions.NewReturn((func() int {
			if localctx.(*InstructionContext).GetInst19() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst19().GetLine()
			}
		}()), (func() int {
			if localctx.(*InstructionContext).GetInst19() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst19().GetLine()
			}
		}()), nil)

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(920)

			var _m = p.Match(ParserParserRW_continue)

			localctx.(*InstructionContext).inst20 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(922)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(921)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = instructions.NewContinue((func() int {
			if localctx.(*InstructionContext).GetInst20() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst20().GetLine()
			}
		}()), (func() int {
			if localctx.(*InstructionContext).GetInst20() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst20().GetLine()
			}
		}()))

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(925)

			var _m = p.Match(ParserParserRW_break)

			localctx.(*InstructionContext).inst21 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(926)
				p.Match(ParserParserTK_semicolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		localctx.(*InstructionContext).result = instructions.NewBreak((func() int {
			if localctx.(*InstructionContext).GetInst21() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst21().GetLine()
			}
		}()), (func() int {
			if localctx.(*InstructionContext).GetInst21() == nil {
				return 0
			} else {
				return localctx.(*InstructionContext).GetInst21().GetLine()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t token.
	GetT() antlr.Token

	// SetT sets the t token.
	SetT(antlr.Token)

	// GetResult returns the result attribute.
	GetResult() utils.AttribsType

	// SetResult sets the result attribute.
	SetResult(utils.AttribsType)

	// Getter signatures
	RW_String() antlr.TerminalNode
	RW_Int() antlr.TerminalNode
	RW_Bool() antlr.TerminalNode
	RW_Character() antlr.TerminalNode
	RW_Float() antlr.TerminalNode

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result utils.AttribsType
	t      antlr.Token
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) GetT() antlr.Token { return s.t }

func (s *TypeContext) SetT(v antlr.Token) { s.t = v }

func (s *TypeContext) GetResult() utils.AttribsType { return s.result }

func (s *TypeContext) SetResult(v utils.AttribsType) { s.result = v }

func (s *TypeContext) RW_String() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_String, 0)
}

func (s *TypeContext) RW_Int() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_Int, 0)
}

func (s *TypeContext) RW_Bool() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_Bool, 0)
}

func (s *TypeContext) RW_Character() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_Character, 0)
}

func (s *TypeContext) RW_Float() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_Float, 0)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *ParserParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ParserParserRULE_type)
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_String:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)

			var _m = p.Match(ParserParserRW_String)

			localctx.(*TypeContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetColumn()
			}
		}()), utils.STRING, true)

	case ParserParserRW_Int:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(934)

			var _m = p.Match(ParserParserRW_Int)

			localctx.(*TypeContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetColumn()
			}
		}()), utils.INT, true)

	case ParserParserRW_Bool:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(936)

			var _m = p.Match(ParserParserRW_Bool)

			localctx.(*TypeContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetColumn()
			}
		}()), utils.BOOLEAN, true)

	case ParserParserRW_Character:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(938)

			var _m = p.Match(ParserParserRW_Character)

			localctx.(*TypeContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetColumn()
			}
		}()), utils.CHAR, true)

	case ParserParserRW_Float:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(940)

			var _m = p.Match(ParserParserRW_Float)

			localctx.(*TypeContext).t = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeContext).GetT() == nil {
				return 0
			} else {
				return localctx.(*TypeContext).GetT().GetColumn()
			}
		}()), utils.FLOAT, true)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCompContext is an interface to support dynamic dispatch.
type ITypeCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetI returns the i token.
	GetI() antlr.Token

	// SetI sets the i token.
	SetI(antlr.Token)

	// GetT returns the t rule contexts.
	GetT() ITypeContext

	// SetT sets the t rule contexts.
	SetT(ITypeContext)

	// GetResult returns the result attribute.
	GetResult() utils.AttribsType

	// SetResult sets the result attribute.
	SetResult(utils.AttribsType)

	// Getter signatures
	Type_() ITypeContext
	TK_id() antlr.TerminalNode

	// IsTypeCompContext differentiates from other interfaces.
	IsTypeCompContext()
}

type TypeCompContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result utils.AttribsType
	t      ITypeContext
	i      antlr.Token
}

func NewEmptyTypeCompContext() *TypeCompContext {
	var p = new(TypeCompContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typeComp
	return p
}

func InitEmptyTypeCompContext(p *TypeCompContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_typeComp
}

func (*TypeCompContext) IsTypeCompContext() {}

func NewTypeCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCompContext {
	var p = new(TypeCompContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_typeComp

	return p
}

func (s *TypeCompContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCompContext) GetI() antlr.Token { return s.i }

func (s *TypeCompContext) SetI(v antlr.Token) { s.i = v }

func (s *TypeCompContext) GetT() ITypeContext { return s.t }

func (s *TypeCompContext) SetT(v ITypeContext) { s.t = v }

func (s *TypeCompContext) GetResult() utils.AttribsType { return s.result }

func (s *TypeCompContext) SetResult(v utils.AttribsType) { s.result = v }

func (s *TypeCompContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeCompContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *TypeCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterTypeComp(s)
	}
}

func (s *TypeCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitTypeComp(s)
	}
}

func (p *ParserParser) TypeComp() (localctx ITypeCompContext) {
	localctx = NewTypeCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ParserParserRULE_typeComp)
	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ParserParserRW_Int, ParserParserRW_Float, ParserParserRW_String, ParserParserRW_Bool, ParserParserRW_Character:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(944)

			var _x = p.Type_()

			localctx.(*TypeCompContext).t = _x
		}
		localctx.(*TypeCompContext).result = localctx.(*TypeCompContext).GetT().GetResult()

	case ParserParserTK_id:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(947)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*TypeCompContext).i = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TypeCompContext).result = *utils.NewAttribsType((func() int {
			if localctx.(*TypeCompContext).GetI() == nil {
				return 0
			} else {
				return localctx.(*TypeCompContext).GetI().GetLine()
			}
		}()), (func() int {
			if localctx.(*TypeCompContext).GetI() == nil {
				return 0
			} else {
				return localctx.(*TypeCompContext).GetI().GetColumn()
			}
		}()), (func() string {
			if localctx.(*TypeCompContext).GetI() == nil {
				return ""
			} else {
				return localctx.(*TypeCompContext).GetI().GetText()
			}
		}()), false)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpContext is an interface to support dynamic dispatch.
type IExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetId returns the id token.
	GetId() antlr.Token

	// GetS returns the s token.
	GetS() antlr.Token

	// GetN returns the n token.
	GetN() antlr.Token

	// GetP returns the p token.
	GetP() antlr.Token

	// SetId sets the id token.
	SetId(antlr.Token)

	// SetS sets the s token.
	SetS(antlr.Token)

	// SetN sets the n token.
	SetN(antlr.Token)

	// SetP sets the p token.
	SetP(antlr.Token)

	// GetE returns the e rule contexts.
	GetE() IExpContext

	// GetE1 returns the e1 rule contexts.
	GetE1() IExpContext

	// GetIndex returns the index rule contexts.
	GetIndex() IDimsContext

	// GetE2 returns the e2 rule contexts.
	GetE2() IExpContext

	// GetT returns the t rule contexts.
	GetT() ITypeContext

	// GetU returns the u rule contexts.
	GetU() IUseattribsContext

	// GetC returns the c rule contexts.
	GetC() ICallfuncContext

	// SetE sets the e rule contexts.
	SetE(IExpContext)

	// SetE1 sets the e1 rule contexts.
	SetE1(IExpContext)

	// SetIndex sets the index rule contexts.
	SetIndex(IDimsContext)

	// SetE2 sets the e2 rule contexts.
	SetE2(IExpContext)

	// SetT sets the t rule contexts.
	SetT(ITypeContext)

	// SetU sets the u rule contexts.
	SetU(IUseattribsContext)

	// SetC sets the c rule contexts.
	SetC(ICallfuncContext)

	// GetResult returns the result attribute.
	GetResult() interfaces.Expression

	// SetResult sets the result attribute.
	SetResult(interfaces.Expression)

	// Getter signatures
	TK_id() antlr.TerminalNode
	Dims() IDimsContext
	TK_minus() antlr.TerminalNode
	AllExp() []IExpContext
	Exp(i int) IExpContext
	TK_not() antlr.TerminalNode
	TK_lpar() antlr.TerminalNode
	TK_rpar() antlr.TerminalNode
	Type_() ITypeContext
	Useattribs() IUseattribsContext
	RW_self() antlr.TerminalNode
	TK_dot() antlr.TerminalNode
	Callfunc() ICallfuncContext
	RW_nil() antlr.TerminalNode
	TK_string() antlr.TerminalNode
	TK_char() antlr.TerminalNode
	TK_int() antlr.TerminalNode
	TK_float() antlr.TerminalNode
	RW_true() antlr.TerminalNode
	RW_false() antlr.TerminalNode
	TK_mult() antlr.TerminalNode
	TK_div() antlr.TerminalNode
	TK_mod() antlr.TerminalNode
	TK_plus() antlr.TerminalNode
	TK_lessequ() antlr.TerminalNode
	TK_moreequ() antlr.TerminalNode
	TK_less() antlr.TerminalNode
	TK_more() antlr.TerminalNode
	TK_equequ() antlr.TerminalNode
	TK_notequ() antlr.TerminalNode
	TK_and() antlr.TerminalNode
	TK_or() antlr.TerminalNode
	RW_isEmpty() antlr.TerminalNode
	RW_count() antlr.TerminalNode

	// IsExpContext differentiates from other interfaces.
	IsExpContext()
}

type ExpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	result interfaces.Expression
	e      IExpContext
	e1     IExpContext
	id     antlr.Token
	index  IDimsContext
	s      antlr.Token
	e2     IExpContext
	t      ITypeContext
	u      IUseattribsContext
	c      ICallfuncContext
	n      antlr.Token
	p      antlr.Token
}

func NewEmptyExpContext() *ExpContext {
	var p = new(ExpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_exp
	return p
}

func InitEmptyExpContext(p *ExpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ParserParserRULE_exp
}

func (*ExpContext) IsExpContext() {}

func NewExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpContext {
	var p = new(ExpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ParserParserRULE_exp

	return p
}

func (s *ExpContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpContext) GetId() antlr.Token { return s.id }

func (s *ExpContext) GetS() antlr.Token { return s.s }

func (s *ExpContext) GetN() antlr.Token { return s.n }

func (s *ExpContext) GetP() antlr.Token { return s.p }

func (s *ExpContext) SetId(v antlr.Token) { s.id = v }

func (s *ExpContext) SetS(v antlr.Token) { s.s = v }

func (s *ExpContext) SetN(v antlr.Token) { s.n = v }

func (s *ExpContext) SetP(v antlr.Token) { s.p = v }

func (s *ExpContext) GetE() IExpContext { return s.e }

func (s *ExpContext) GetE1() IExpContext { return s.e1 }

func (s *ExpContext) GetIndex() IDimsContext { return s.index }

func (s *ExpContext) GetE2() IExpContext { return s.e2 }

func (s *ExpContext) GetT() ITypeContext { return s.t }

func (s *ExpContext) GetU() IUseattribsContext { return s.u }

func (s *ExpContext) GetC() ICallfuncContext { return s.c }

func (s *ExpContext) SetE(v IExpContext) { s.e = v }

func (s *ExpContext) SetE1(v IExpContext) { s.e1 = v }

func (s *ExpContext) SetIndex(v IDimsContext) { s.index = v }

func (s *ExpContext) SetE2(v IExpContext) { s.e2 = v }

func (s *ExpContext) SetT(v ITypeContext) { s.t = v }

func (s *ExpContext) SetU(v IUseattribsContext) { s.u = v }

func (s *ExpContext) SetC(v ICallfuncContext) { s.c = v }

func (s *ExpContext) GetResult() interfaces.Expression { return s.result }

func (s *ExpContext) SetResult(v interfaces.Expression) { s.result = v }

func (s *ExpContext) TK_id() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_id, 0)
}

func (s *ExpContext) Dims() IDimsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDimsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *ExpContext) TK_minus() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_minus, 0)
}

func (s *ExpContext) AllExp() []IExpContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpContext); ok {
			len++
		}
	}

	tst := make([]IExpContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpContext); ok {
			tst[i] = t.(IExpContext)
			i++
		}
	}

	return tst
}

func (s *ExpContext) Exp(i int) IExpContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpContext)
}

func (s *ExpContext) TK_not() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_not, 0)
}

func (s *ExpContext) TK_lpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lpar, 0)
}

func (s *ExpContext) TK_rpar() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_rpar, 0)
}

func (s *ExpContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ExpContext) Useattribs() IUseattribsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseattribsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseattribsContext)
}

func (s *ExpContext) RW_self() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_self, 0)
}

func (s *ExpContext) TK_dot() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_dot, 0)
}

func (s *ExpContext) Callfunc() ICallfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallfuncContext)
}

func (s *ExpContext) RW_nil() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_nil, 0)
}

func (s *ExpContext) TK_string() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_string, 0)
}

func (s *ExpContext) TK_char() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_char, 0)
}

func (s *ExpContext) TK_int() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_int, 0)
}

func (s *ExpContext) TK_float() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_float, 0)
}

func (s *ExpContext) RW_true() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_true, 0)
}

func (s *ExpContext) RW_false() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_false, 0)
}

func (s *ExpContext) TK_mult() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_mult, 0)
}

func (s *ExpContext) TK_div() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_div, 0)
}

func (s *ExpContext) TK_mod() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_mod, 0)
}

func (s *ExpContext) TK_plus() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_plus, 0)
}

func (s *ExpContext) TK_lessequ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_lessequ, 0)
}

func (s *ExpContext) TK_moreequ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_moreequ, 0)
}

func (s *ExpContext) TK_less() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_less, 0)
}

func (s *ExpContext) TK_more() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_more, 0)
}

func (s *ExpContext) TK_equequ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_equequ, 0)
}

func (s *ExpContext) TK_notequ() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_notequ, 0)
}

func (s *ExpContext) TK_and() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_and, 0)
}

func (s *ExpContext) TK_or() antlr.TerminalNode {
	return s.GetToken(ParserParserTK_or, 0)
}

func (s *ExpContext) RW_isEmpty() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_isEmpty, 0)
}

func (s *ExpContext) RW_count() antlr.TerminalNode {
	return s.GetToken(ParserParserRW_count, 0)
}

func (s *ExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.EnterExp(s)
	}
}

func (s *ExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ParserListener); ok {
		listenerT.ExitExp(s)
	}
}

func (p *ParserParser) Exp() (localctx IExpContext) {
	return p.exp(0)
}

func (p *ParserParser) exp(_p int) (localctx IExpContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 104
	p.EnterRecursionRule(localctx, 104, ParserParserRULE_exp, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(952)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ExpContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(953)

			var _x = p.dims(0)

			localctx.(*ExpContext).index = _x
		}
		localctx.(*ExpContext).result = expressions.NewAccessArray((func() int {
			if localctx.(*ExpContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetId().GetText()
			}
		}()), localctx.(*ExpContext).GetIndex().GetResult())

	case 2:
		{
			p.SetState(956)

			var _m = p.Match(ParserParserTK_minus)

			localctx.(*ExpContext).s = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(957)

			var _x = p.exp(21)

			localctx.(*ExpContext).e2 = _x
		}
		localctx.(*ExpContext).result = expressions.NewArithmetic((func() int {
			if localctx.(*ExpContext).GetS() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetS().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetS() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetS().GetColumn()
			}
		}()), nil, (func() string {
			if localctx.(*ExpContext).GetS() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetS().GetText()
			}
		}()), localctx.(*ExpContext).GetE2().GetResult())

	case 3:
		{
			p.SetState(960)

			var _m = p.Match(ParserParserTK_not)

			localctx.(*ExpContext).s = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(961)

			var _x = p.exp(15)

			localctx.(*ExpContext).e2 = _x
		}
		localctx.(*ExpContext).result = expressions.NewLogic((func() int {
			if localctx.(*ExpContext).GetS() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetS().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetS() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetS().GetColumn()
			}
		}()), nil, (func() string {
			if localctx.(*ExpContext).GetS() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetS().GetText()
			}
		}()), localctx.(*ExpContext).GetE2().GetResult())

	case 4:
		{
			p.SetState(964)

			var _x = p.Type_()

			localctx.(*ExpContext).t = _x
		}
		{
			p.SetState(965)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)

			var _x = p.exp(0)

			localctx.(*ExpContext).e = _x
		}
		{
			p.SetState(967)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewCast(localctx.(*ExpContext).GetT().GetResult().Line, localctx.(*ExpContext).GetT().GetResult().Column, localctx.(*ExpContext).GetT().GetResult().Value.(utils.Type), localctx.(*ExpContext).GetE().GetResult())

	case 5:
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(970)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(971)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(974)

			var _x = p.Useattribs()

			localctx.(*ExpContext).u = _x
		}
		localctx.(*ExpContext).result = localctx.(*ExpContext).GetU().GetResult()

	case 6:
		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(977)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(978)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(981)

			var _x = p.Callfunc()

			localctx.(*ExpContext).c = _x
		}
		localctx.(*ExpContext).result = localctx.(*ExpContext).GetC().GetResult()

	case 7:
		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ParserParserRW_self {
			{
				p.SetState(984)
				p.Match(ParserParserRW_self)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(985)
				p.Match(ParserParserTK_dot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(988)

			var _m = p.Match(ParserParserTK_id)

			localctx.(*ExpContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewAccessID((func() int {
			if localctx.(*ExpContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetId().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetId() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetId().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetId() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetId().GetText()
			}
		}()))

	case 8:
		{
			p.SetState(990)

			var _m = p.Match(ParserParserRW_nil)

			localctx.(*ExpContext).n = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()), utils.NIL)

	case 9:
		{
			p.SetState(992)

			var _m = p.Match(ParserParserTK_string)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}())[1:len((func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()))-1], utils.STRING)

	case 10:
		{
			p.SetState(994)

			var _m = p.Match(ParserParserTK_char)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}())[1:len((func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()))-1], utils.CHAR)

	case 11:
		{
			p.SetState(996)

			var _m = p.Match(ParserParserTK_int)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()), utils.INT)

	case 12:
		{
			p.SetState(998)

			var _m = p.Match(ParserParserTK_float)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()), utils.FLOAT)

	case 13:
		{
			p.SetState(1000)

			var _m = p.Match(ParserParserRW_true)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()), utils.BOOLEAN)

	case 14:
		{
			p.SetState(1002)

			var _m = p.Match(ParserParserRW_false)

			localctx.(*ExpContext).p = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = expressions.NewPrimitive((func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExpContext).GetP() == nil {
				return 0
			} else {
				return localctx.(*ExpContext).GetP().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExpContext).GetP() == nil {
				return ""
			} else {
				return localctx.(*ExpContext).GetP().GetText()
			}
		}()), utils.BOOLEAN)

	case 15:
		{
			p.SetState(1004)
			p.Match(ParserParserTK_lpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1005)

			var _x = p.exp(0)

			localctx.(*ExpContext).e = _x
		}
		{
			p.SetState(1006)
			p.Match(ParserParserTK_rpar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExpContext).result = localctx.(*ExpContext).GetE().GetResult()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1054)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1011)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(1012)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpContext).s = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&985162418487296) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpContext).s = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1013)

					var _x = p.exp(21)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewArithmetic(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 2:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1016)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(1017)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpContext).s = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ParserParserTK_plus || _la == ParserParserTK_minus) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpContext).s = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1018)

					var _x = p.exp(20)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewArithmetic(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 3:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1021)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1022)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpContext).s = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ParserParserTK_lessequ || _la == ParserParserTK_moreequ) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpContext).s = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1023)

					var _x = p.exp(19)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewRelational(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 4:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1026)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(1027)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpContext).s = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ParserParserTK_less || _la == ParserParserTK_more) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpContext).s = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1028)

					var _x = p.exp(18)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewRelational(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 5:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1031)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1032)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExpContext).s = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == ParserParserTK_equequ || _la == ParserParserTK_notequ) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExpContext).s = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1033)

					var _x = p.exp(17)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewRelational(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 6:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1036)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1037)

					var _m = p.Match(ParserParserTK_and)

					localctx.(*ExpContext).s = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1038)

					var _x = p.exp(15)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewLogic(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 7:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e1 = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1041)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1042)

					var _m = p.Match(ParserParserTK_or)

					localctx.(*ExpContext).s = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1043)

					var _x = p.exp(14)

					localctx.(*ExpContext).e2 = _x
				}
				localctx.(*ExpContext).result = expressions.NewLogic(localctx.(*ExpContext).GetE1().GetResult().LineN(), localctx.(*ExpContext).GetE1().GetResult().ColumnN(), localctx.(*ExpContext).GetE1().GetResult(), (func() string {
					if localctx.(*ExpContext).GetS() == nil {
						return ""
					} else {
						return localctx.(*ExpContext).GetS().GetText()
					}
				}()), localctx.(*ExpContext).GetE2().GetResult())

			case 8:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1046)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1047)
					p.Match(ParserParserTK_dot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1048)
					p.Match(ParserParserRW_isEmpty)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ExpContext).result = expressions.NewIsEmpty(localctx.(*ExpContext).GetE().GetResult().LineN(), localctx.(*ExpContext).GetE().GetResult().ColumnN(), localctx.(*ExpContext).GetE().GetResult())

			case 9:
				localctx = NewExpContext(p, _parentctx, _parentState)
				localctx.(*ExpContext).e = _prevctx
				p.PushNewRecursionContext(localctx, _startState, ParserParserRULE_exp)
				p.SetState(1050)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1051)
					p.Match(ParserParserTK_dot)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1052)
					p.Match(ParserParserRW_count)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*ExpContext).result = expressions.NewCount(localctx.(*ExpContext).GetE().GetResult().LineN(), localctx.(*ExpContext).GetE().GetResult().ColumnN(), localctx.(*ExpContext).GetE().GetResult())

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ParserParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *InstsglobalContext = nil
		if localctx != nil {
			t = localctx.(*InstsglobalContext)
		}
		return p.Instsglobal_Sempred(t, predIndex)

	case 4:
		var t *ListargsContext = nil
		if localctx != nil {
			t = localctx.(*ListargsContext)
		}
		return p.Listargs_Sempred(t, predIndex)

	case 9:
		var t *ListparamsContext = nil
		if localctx != nil {
			t = localctx.(*ListparamsContext)
		}
		return p.Listparams_Sempred(t, predIndex)

	case 16:
		var t *CasesContext = nil
		if localctx != nil {
			t = localctx.(*CasesContext)
		}
		return p.Cases_Sempred(t, predIndex)

	case 27:
		var t *ListexpContext = nil
		if localctx != nil {
			t = localctx.(*ListexpContext)
		}
		return p.Listexp_Sempred(t, predIndex)

	case 32:
		var t *VectorsContext = nil
		if localctx != nil {
			t = localctx.(*VectorsContext)
		}
		return p.Vectors_Sempred(t, predIndex)

	case 37:
		var t *DimsContext = nil
		if localctx != nil {
			t = localctx.(*DimsContext)
		}
		return p.Dims_Sempred(t, predIndex)

	case 39:
		var t *ListattribsContext = nil
		if localctx != nil {
			t = localctx.(*ListattribsContext)
		}
		return p.Listattribs_Sempred(t, predIndex)

	case 48:
		var t *InstructionsContext = nil
		if localctx != nil {
			t = localctx.(*InstructionsContext)
		}
		return p.Instructions_Sempred(t, predIndex)

	case 52:
		var t *ExpContext = nil
		if localctx != nil {
			t = localctx.(*ExpContext)
		}
		return p.Exp_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ParserParser) Instsglobal_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Listargs_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Listparams_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Cases_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Listexp_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Vectors_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Dims_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Listattribs_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Instructions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ParserParser) Exp_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 22)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
